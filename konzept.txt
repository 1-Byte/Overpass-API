nodes: Index = LL_upper, Object = Id LL_lower
node_tags_global: Index = (Key Value), Object = LL_upper Id
node_tags_local: Index = (LL_upper_24 Key Value), Object = Id
ways: Index = LL_upper, Object = Id Count (Node-Id)*
way_tags_global: Index = (Key Value), Object = LL_upper Id
way_tags_local: Index = (LL_upper_24 Key Value), Object = Id
relations: Index = LL_upper, Object = Id Count (Type Id Role-Id)*
relation_tags_global: Index = (Key Value), Object = LL_upper Id
relation_tags_local: Index = (LL_upper_24 Key Value), Object = Id

area-query
bbox-query
filter
query
recurse
print

import
update

---

Update-Abhängigkeiten:
node_tags_global: Um alte Tags finden zu können, müssen wir diese zunächst auslesen. Passiert über node_tags_local
node_tags_local: Um alte Tags finden zu können, müssen wir diese zunächst auslesen. Dies erfordert den alten LL_index der Node, also Lesen von nodes
nodes: Für alten LL_index muss diese Datei sowieso zunächst gelesen werden. Alternativ: LL_index-Verzeichnis

*_tags_global/_local: analog
ways/relations: werden auch aus ihrem LL_index-Verzeichnis ausgerüstet
Für die neuen LL-Indizes müssen allerdings die LL-Indizes der betroffenen Nodes bzw. Ways bekannt sein. (können aus dem aktualisierten LL_index gelesen werden)

Update-Strategie:
a) Nodes
aa) Lese die Löschindizes der alten Nodes aus
ab) Lösche und Aktualisiere die Nodes
ac) Lese die Tags der alten Nodes ein
ad) Lösche und Aktualisiere nodes_local
ae) Lösche und Aktualisiere nodes_global
b) Ways
ba) Lese die Positionen der benutzten Nodes aus LL_index aus
bb) Lese die Löschindizes der alten Ways aus
bc) Lösche und Aktualisiere die Ways
bd) Lese die Tags der alten Ways ein
be) Lösche und Aktualisiere ways_local
bf) Lösche und Aktualisiere ways_global
c) Relations
ca) Lese die Positionen der benutzten Nodes und Ways aus LL_index aus
cb) Lese die Löschindizes der alten Relations aus
cc) Lösche und Aktualisiere die Relations
cd) Lese die Tags der alten Relations ein
ce) Lösche und Aktualisiere relations_local
cf) Lösche und Aktualisiere relations_global

Node_Updater:
to_delete_ids
to_delete_idxs

---

Welcher Index gehört wo hin?
Sei ein Index q gegeben.
a) Gibt es einen Blockindex b mit Index b' des Folgeblocks, so dass b\leq q < b' gilt, so gehört q in diesen Block.
b) q gehört genau dann in einen Mehrfachblock, wenn q gleich dem Blockindex ist.
c) Gehört der größte Blockindex a, der kleiner als q ist, zu einem Mehrfachblock, so gehört q in den Nachfolgeblock.
d) Ist q größer als der größte Blockindex a und dieser ein Mehrfachblock, so gehört q in einen eigenen Block hinterher.
e) Ist q kleiner als jeder Blockindex und der erste Block ist kein Mehrfachblock, so gehört q in den ersten Block.
f) Ist q kleiner als jeder Blockindex und der erste Block ist ein Mehrfachblock, so gehört q in einen eigenen Block voraus.

Anders formuliert:
a) Es gibt "Segmentblöcke" (= mehrere Blöcke enthalten Daten zu nur einem Index) und "Gruppenblöcke" (= Nachfolge- und Vorgängerblock haben beide verschiedene Indizes).
b) Suchen nach Blöcken (zum Lesen wie zum Einfügen) können daher leere Ergebnisse haben, einen oder mehrere Blöcke zurückliefern.
c) Die Blockstruktur der Datenbank definiert eine Zerlegung des Indexraum wie folgt:
- eine Familie von Segmentblöcken ist genau ihr Blockindex zugeordnet
- hat ein Gruppenblock einen Gruppenblock als Vorgänger, so hat er als Untergrenze der Blockindizes seinen eigenen Startwert, sonst der minimale Index oder der Index, der infitesimal größer als der vorhergehende Blockindex ist
- hat ein Gruppenblock einen Gruppenblock oder Segmentblock als Nachfolger, so hat er die Obergrenze infinitesimal kleiner als sein Nachfolgeblock, sonst das Supremum des Indexraums

Pragmatisch:
- wir wollen flach suchen (alles finden), mit einer diskreten Menge von Indizes suchen oder mit der Vereinigung diverser Intervalle suchen können.
- Lesen wollen wir mit allen drei Methoden, schreiben nur mit diskreten Indizes (denn die zu schreibenden und zu löschenden Objekte haben ja Indizes).
- der letzte Block eines Segmentblock-Familie muss beim Schreiben anders behandelt werden.
- wir können keine infinitesimal größeren oder kleineren sowie keine Infima und Suprema sinnvoll generisch darstellen. Für das Lesen reicht es aber, sich auf tatsächlich in der Datenbank vorkommende Indizes zu beschränken, für das Schreiben reicht es, sich auf in der Schreibanfrage vorkommende Indizes zu beschränken.

Flacher Iterator:
  block_type()
  ++, ==, =, (self), ~
  flat_begin(), flat_end()
  read_block(..)

Diskreter Iterator:
  block_type()
  lower_bound(), upper_bound()
  ++, ==, =, (self), ~
discrete_begin(..), discrete_end()
  read_block(..)
insert_block(..)
replace_block(..)

Intervall-Iterator:
block_type()
lower_bound(), upper_bound()
++, ==, =, (self), ~
range_begin(..), range_end()
read_block(..)

Die Semantik von ++, ==, =, (self), ~, *_end() und flat_begin() ist die übliche.
discrete_begin(..) nimmt ein Paar von Iteratoren über einen Container mit Indizes entgegen und iteriert über genau die Blöcke, die für diese Menge von Iteratoren relevant sein können.
range_begin(..) tut das analoge für ein Paar von Iteratoren über einen Container von Intervallen.
block_type() liefert einen der Werte \{ EMPTY, BLOCK, PARTIAL, LAST_PART \}
read_block(..) ist eine Methode von File_Blocks, erhält als Argument einen Iterator und liefert den zugehörigen Datenblock aus.
insert_block(..) ist eine Methode von File_Blocks, erhält als Argument einen diskreten Iterator und fügt den Block unmittelbar vor dem Block ein.
replace_block(..) ist eine Methode von File_Blocks, erhält als Argument einen diskreten Iterator und ersetzt den vom Iterator bezeichneten Block.
lower_bound() liefert die jeweils sinnvolle Untergrenze: für einen diskreten Iterator ist das der kleinste Index aus der Anfragemenge, der zum aktuellen Block des Iterators gehört. Für einen Intervall-Iterator ist dies der kleinste Index, der zum Block gehört und tatsächlich in der Datenbank existiert.
upper_bound() liefert den kleinsten Index, der schon außerhalb des Blocks liegt. Für einen diskreten Iterator ist dies der kleinste Index aus der Anfragemenge, für den dies zutrifft und ggf. ==end(). Bei Intervallen ist es der erste Index des nächsten Blocks oder ==end() im Falle des letzten Blocks in der Datenbank.

0, f96, 260a, 3276, 348c, 34ce

void update(const map< TIndex, map< TObject > >& to_delete,
  const map< TIndex, map< TObject > >& to_insert);

update: 3 Fälle
a) leerer Bestand
b) 1 Block Bestand, ggf. mehrere Blöcke neu
c) mehrere Blöcke Bestand

a)+b) erfordern Algorithmus zur Blockteilung:
- Verwende stets höchstens so viele Blöcke wie nötig, verteile so gleichmäßig wie möglich.
- Wenn zwei aufeinanderfolgende Indizes nicht zusammen in einen Block passen, muss dazwischen geteilt werden.
- Minimal mögliche Anzahl an Blöcken kann per Greedy ermittelt werden.
- Heuristik: fülle von hinten nach vorne jeweils bis zum Durchschnitt auf

calc_split_idxs(vector< TIndex >& split, const map< TIndex, int32 >& sizes);

benötigt: TObject.sizeof()
Größenberechnung: Tindex.sizeof() + sizeof(uint32) + \sum TObject.sizeof()

bei a)
- berechne die Indexgrößen allein aus den Neuzugängen
- schreibe alle Blöcke mittels insert_block(end)

bei b)
- berücksichtigte Bestandsdaten, Löschungen und Neuzugänge für Indexgrößen
- achte auf Indizes, die nicht mehr existieren
- schreibe alle bis auf den letzten Block mittels insert_block(it), dann replace_block(it)

bei c)
- fülle Blöcke mit Löschungen mit Neudaten auf, sofern möglich
- fülle den letzten Block auf, also replace_block bzw. insert_block
- wenn etwas übrig bleibt, hänge einen Block an, also replace_block und insert_block davor

---
zum Thema Discrete_Iterator, hier: Verifikation von operator++ und Konstruktor

Konstruktor:

Wenn Indizes leer, dann Ende
Wenn leer, dann leer zurück [ index_upper = (end) ]
Wenn Block Segment ist und Index < Block.Index
  is_empty = true [ index_upper der erste Index, der >= Block.Index ist ]
Wenn (Nachfolger != (end) && Nachfolger.Index <= erster Index)
{
  Wenn (Index == erster Index)
    Segment (einzige Möglichkeit für Segment): liefere dieses zurück [ index_upper = index + 1 ]
  ++Block, ++Nachfolger
}
(*)
Wenn (Nachfolger == (end))
{
  (relevantes Segment kann nicht passieren, da Segmente mehrteilig sind)
  wenn Last_Segment, dann liefere dahinter (leer) zurück [ index_upper = (end) ]
  ansonsten liefere diesen Block zurück [ index_upper = (end) ]
}
Wenn (Block ein Last_Segment ist)
  is_empty = true [ index_upper der erste Index, der >= Block.Index ist ]
liefere Block zurück [ index_upper der erste Index, der >= Nachfolger.Index ist ]

Wohldef: ok
Terminierung: ok, da endlich viele Blöcke
Korrektheit:
- richtiger Block: nur erster Index relevant. Korrekt, falls er auf ein Segment passt. An (*) gilt, dass (Nachfolger == (end) || (Nachfolger.Index > erster Index)), also wird auf keinen Fall ein zur kleiner Block zurückgeliefert. Außerdem gilt für keinen Block vor Nachfolger, dass (Index > erster Index). Also richtiger Block.
- index_upper: für Segments korrekt per Definition, für Groups per Konstruktion

---

operator++:

mögliche Zustände:
- group
- segment
- last_segment
- is_inserted
- is_empty (bezieht sich auf den Folgeblock wenn is_inserted gesetzt ist)

Wenn (is_inserted)
  liefere ++Block zurück [ index, is_empty unverändert ]
Wenn (is_empty)
  setze (is_empty) zurück
  setze index_lower = index_upper und index_upper:
    falls Block == (end) auf (end)
    ansonsten [ index_upper der erste Index, der >= Block.Index ist ]
  fertig
Wenn Segment
  liefere ++Block zurück, Indices unverändert
(*)
index_lower = index_upper
++Block
Wenn (Block == (end))
  fertig
Wenn Block Segment ist und Index < Block.Index
  is_empty = true [ index_upper der erste Index, der >= Block.Index ist ]
Wenn (Nachfolger != (end) && Nachfolger.Index <= erster Index)
{
  Wenn (Index == erster Index)
    Segment (einzige Möglichkeit für Segment): liefere dieses zurück [ index_upper = index + 1 ]
  ++Block, ++Nachfolger
}
Wenn (Nachfolger == (end))
{
  (relevantes Segment kann nicht passieren, da Segmente mehrteilig sind)
  wenn Last_Segment, dann liefere dahinter (leer) zurück [ index_upper = (end) ]
  ansonsten liefere diesen Block zurück [ index_upper = (end) ]
}
Wenn (Block ein Last_Segment ist)
  is_empty = true [ index_upper der erste Index, der >= Block.Index ist ]
liefere Block zurück [ index_upper der erste Index, der >= Nachfolger.Index ist ]

Ab (*) gilt, dass mit dem Ende von Block alle Indices mit < index_upper abgearbeitet sind.
Wohldef: ok
Terminierung: ok, da endlich viele Blöcke
Korrektheit:
- richtiger Block: Im Normalfall wird (*) erreicht, dann siehe oben. Für Segments wird korrekt der Folgeblock zurückgeliefert. is_empty und is_inserted werden ebenso explizit behandelt
- index_lower: s. index_upper
- index_upper: Im Normalfall wird (*) erreicht, dann siehe oben. Segments, is_empty und is_inserted werden explizit behandelt.

---

insert

Zusicherung:
- es gilt is_writeable (Ausnahme!)
- es ist nicht is_inserted gesetzt (Ausnahme!)
- es werden nur Indices eingetragen, die >= index_lower und < index_upper sind
- für jeden Index in diesem Block gilt, dass er kleiner als Block.Index (des Blocks unter dem Iterator) wird, nachdem der Block bearbeitet ist.

Block wird auf den neuen Block gesetzt und dessen Index in die Blockliste aufgenommen; es wird is_inserted gesetzt. Achtung: is_empty bezieht sich (wie die Indexgrenzen) nun auf den Folgeblock.

---

replace

Zusicherung:
- es gilt is_writeable (Ausnahme!)
- es gilt nicht is_empty (Ausnahme!)
- es werden nur Indices und alle verbleibenden Indices eingetragen, die >= index_lower und < index_upper sind

Durch die Zusicherung ist sichergestellt, dass sich dies so mit operator++ verträgt.

---

replace delete

Zusicherung:
- es gilt is_writeable (Ausnahme!)
- es gilt nicht is_empty (Ausnahme!)

Es wird zum nächsten Block gewechselt. Durch die Zusicherung ist sichergestellt, dass sich dies so mit operator++ verträgt.
