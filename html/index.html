<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" lang="en"></meta>
  <title>OSM Server Side Script</title>
</head>
<body>

<h1>OSM Server Side Script</h1>

<p>
<a href="#chapter.introduction">Introduction</a> -
<a href="#chapter.use_cases">Use Cases</a> -
<a href="#chapter.interface_calls">Interface Calls</a> -
<a href="#chapter.statements">Statements</a> -
<a href="#chapter.concepts">Concepts</a> -
<a href="#chapter.input_formats">Input Formats</a> -
<a href="#chapter.output_formats">Output Formats</a>
</p>

<div>
<h2>Table of Contents</h2>
</div>

<p>
<a href="#chapter.introduction">Introduction</a><br/>
<a href="#chapter.use_cases">Use Cases</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.reverse_gazetteer">To which country belongs this location?</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.download_area">Download an entire city</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.debug_area">Why doesn't my city appear?</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.rule_example">Declare a new type of area</a><br/>
<a href="#chapter.interface_calls">Interface Calls</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.interpreter">/api/interpreter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.get_rule">/api/get_rule</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.add_rule">/api/add_rule</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.update_rule">/api/update_rule</a><br/>
<a href="#chapter.statements">Statements</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.area_query">area-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.bbox_query">bbox-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.conflict">conflict</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.coord_query">coord-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.detect_odd_nodes">detect-odd-nodes</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.foreach">foreach</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.id_query">id-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.item">item</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.make_area">make-area</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.osm_script">osm-script</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.print">print</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.query">query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.recurse">recurse</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.report">report</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.union">union</a><br/>
<a href="#chapter.concepts">Concepts</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.data_structures">Data structures</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.queries_rules">Queries and Rules</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.control_flow">Control Flow</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.variables">Variables</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.other_sets">Other Sets in Scripts</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.flow_forecast">Flow Forecast</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.quotas">Limits and Quotas</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.database_layout">Database Layout</a><br/>
<a href="#chapter.input_formats">Input Formats</a><br/>
<a href="#chapter.output_formats">Output Formats</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.payload">Payload</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.status_remarks">Status Remarks</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.hypertext_reports">Hypertext Reports</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.static_feedback">Static Error Feedback</a><br/>
</p>

<!-- ==================================================================== //-->

<div>
<a id="chapter.introduction"/>
<h2>Introduction</h2>
</div>

<p>
</p>

<!-- ==================================================================== //-->

<div>
<a id="chapter.use_cases"/>
<h2>Use Cases</h2>
</div>

<p>
<a href="#section.reverse_gazetteer">To which country belongs this location?</a><br/>
<a href="#section.download_area">Download an entire city</a><br/>
<a href="#section.debug_area">Why doesn't my city appear?</a><br/>
<a href="#section.rule_example">Declare a new type of area</a><br/>
</p>

<p>The following examples are some sample use cases to give you an idea what you can do with the system. Of course, there are many more useful use cases, and you are kindly invited to add other use cases in the wiki.</p>

<div>
<a id="section.reverse_gazetteer"/>
<h3>To which country belongs this location?</h3>
</div>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
To determine in which areas a location specified by latitude and longitude lies, just change the latitude and longitude in the following query to appriate values: If your browser asks you what to do, just open the file with a text editor.<br/>
<textarea name="data" rows="3" cols="80">&lt;coord-query lat="51.25" lon="7.15"/&gt;
&lt;print mode="body"/&gt;
</textarea>
<input type="submit" value="Explore"/>
<br/>
Of course, you can send this query also via any other <a href="#chapter.input_formats">way of submitting input</a> to <a href="#section.interpreter">/api/interpreter</a>. You will recieve a gzip-compressed XML-file in an <a href="#chapter.output_formats">adapted OSM format</a> that <a href="#section.payload">contains the areas</a> the location lies in.
</p>
</form>

<p>
The first command, <a href="#section.coord_query">&lt;coord-query lat="51.25" lon="7.15"/&gt;</a>, searches the database for every area that covers the location defined by the latitude and longitude values. Then it stores the result into the <a href="#section.variables">default set</a>. Afterwards, the second command <a href="#section.print">&lt;print mode="body"/&gt;</a> prints the content of the default set. The mode="body" indicates there that it shall print the <a href="#section.data_structures">id</a> of the area as well as its <a href="#section.data_structures">tags</a>.<br/>
</p>

<div>
<a id="section.download_area"/>
<h3>Download an entire city</h3>
</div>

<p>
This is in general a two-step process. For the first step, determine the id of the area to download, e.g. from the result of a <a href="#section.coord_query">coord-query</a> like in the <a href="#section.reverse_gazetteer">above example</a>. Another way to determine the id is to take advantage of <a href="#section.data_structures">the way the areas obtain their id</a>:
</p>
<ul>
<li>An area based on a node has the same id as the node.</li>
<li>An area based on a way has the the id of the way plus 2,400,000,000.</li>
<li>An area based on a relation has the id of the relation plus 3,600,000,000.</li>
</ul>
<p>
For example, the area representing the German city "Wuppertal" has id 3,600,062,478 because its pivot element is the relation 62,478 describing the borders of Wuppertal. In particular this means that area ids are as stable as the ids in the OSM database. If you don't know the id of the OSM entity in question, then can simply <a href="#section.query">query</a> it.
</p>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
The second step is the query to actually download the area: This query will take 15-30 seconds before it gives a response depending on server load.<br/>
<textarea name="data" rows="8" cols="80">&lt;union&gt;
  &lt;area-query ref="3600062478"/&gt;
  &lt;recurse type="node-relation" into="rels"/&gt;
  &lt;recurse type="node-way"/&gt;
  &lt;recurse type="way-relation"/&gt;
&lt;/union&gt;
&lt;print mode="body"/&gt;
</textarea>
<input type="submit" value="Download"/>
<br/>
Again, you can send this query also via any other <a href="#chapter.input_formats">way of submitting input</a> to <a href="#section.interpreter">/api/interpreter</a>. You will recieve a gzip-compressed XML-file in an <a href="#chapter.output_formats">adapted OSM format</a> that <a href="#section.payload">contains</a> all nodes that lie in this area (including all the nodes on the boundary), all ways that are referred from such a node and all relations that are referred by such a way or such a node.
</p>
</form>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
If you prefer to receive additionally all nodes any way refers to, you can change the query to: This query also will take some time depending on server load before it gives a response.<br/>
<textarea name="data" rows="16" cols="80">&lt;osm-script timeout="180"&gt;

&lt;union&gt;
  &lt;area-query ref="3600062478"/&gt;
  &lt;recurse type="node-relation" into="rels"/&gt;
  &lt;recurse type="node-way"/&gt;
  &lt;recurse type="way-relation"/&gt;
&lt;/union&gt;
&lt;union&gt;
  &lt;item/&gt;
  &lt;recurse type="way-node"/&gt;
&lt;/union&gt;
&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
<input type="submit" value="Download"/>
<br/>
</p>
</form>

<p>
We briefly explain both queries and start with the first one: The statement <a href="#section.union">&lt;union&gt;</a> <a href="#section.other_sets">collects</a> the output of the enclosed statements in line 2 to 6. The block starts with the query <a href="#section.area_query">&lt;area-query ref="3600062478"/&gt;</a>. This statement returns all the nodes that lie inside or on the border of the area with id given by the parameter ref and stores them in into the <a href="#section.variables">default set</a>. In the third line, <a href="#section.recurse">&lt;recurse type="node-relation" into="rels"/&gt;</a> returns all relations that have as member a node from the input, in this case the <a href="#section.variables">default set</a>, into the set "rels". As this happens within an <a href="#section.union">union</a>-block, the new content of the set "rels" is added to the result of the <a href="#section.union">union</a>-block as a whole. In the next line, <a href="#section.recurse">&lt;recurse type="node-way"/&gt;</a> puts into the <a href="#section.variables">default set</a> the ways that refer to at least one node from the <a href="#section.variables">default set</a>. In particular, the default set now contains only ways, the <a href="#section.union">union</a>-block has collected so far all nodes and ways and some relations. In the last line of the block, <a href="#section.recurse">&lt;recurse type="way-relation"/&gt;</a> puts into the <a href="#section.variables">default set</a> all relations that refer to at least one way from the <a href="#section.variables">default set</a> beforehand. The <a href="#section.union">union</a>-block again collects these relations. Now the <a href="#section.union">union</a>-block contains altogether the nodes within the area and the ways and relations that refer to such a node or way. As there is no output parameter given, this set is stored into the <a href="#section.variables">default set</a>. The statement after the block, <a href="#section.print">&lt;print mode="body"/&gt;</a> then prints the entire content of the <a href="#section.variables">default set</a> with all its details as specified by the value "body" of the parameter "mode".
</p>

<p>
The second query differs from the first one in two aspects: It exhibits the root element <a href="#section.osm_script">&lt;osm-script timeout="180"&gt;</a> to change a global setting from its default: Without explicit timeout, the server <a href="#section.flow_forecast">forecasts</a> the runtime of the query and refuses its execution if it could take too much ressources. With a manual <a href="#section.quotas">timeout</a>, the query will be accepted regardless of its predicted runtime, but it will be aborted if it exceeeds its timeout. The second difference is the second <a href="#section.union">union</a>-block: The first statement <a href="#section.item">&lt;item/&gt;</a> just makes the current <a href="#section.variables">default set</a> part of the result of the <a href="#section.union">union</a>-block. The second statement <a href="#section.recurse">&lt;recurse type="way-node"/&gt;</a> replaces the <a href="#section.variables">default set</a> with the set of all nodes that are referred by the ways in the <a href="#section.variables">default set</a> beforehand. This result is collected by the <a href="#section.union">union</a>-block. Thus, the result now conatins all nodes that are referred by a way appearing in the set.
</p>

<div>
<a id="section.debug_area"/>
<h3>Why doesn't my city appear?</h3>
</div>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
You may get into the situation that you don't find an area where you expect one. In particular, a coord-query like the <a href="#section.reverse_gazetteer">first</a> use case doesn't contain the data of an area although there exists for example a relation to create it. In this case, you can query the <a href="#section.data_structures">conflicts</a> that prevented the respective area creation <a href="#section.queries_rules">rule</a> to create an area from this. The following query will try to find conflicts related to the relation of the German city "Wuppertal": You should replace "Wuppertal, Stadt" by a suitable value for you relation.
<textarea name="data" rows="5" cols="80">&lt;query type="relation"&gt;
  &lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;
&lt;/query&gt;
&lt;report/&gt;
</textarea>
<input type="submit" value="Find Conflicts"/>
<br/>
The server will return a <a href="#section.hypertext_reports">human readable HTML document</a> that lists the conflicts related to this relation; these are generated by <a href="#section.rule_example">user editable rules</a> and should be self-explanatory. The result can be empty (and probably will be empty for Wuppertal because the respective area has successfully been created), but we simply can't leave an area in permanently broken state to show how the conflict feedback system works.
</p>
</form>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
If you get an empty result from the first query, check whether there exists a relation at all:
<textarea name="data" rows="5" cols="80">&lt;query type="relation"&gt;
  &lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;
&lt;/query&gt;
&lt;print mode="body"/&gt;
</textarea>
<input type="submit" value="Find Relations"/>
<br/>
This searches the data for all relations that match the given criteria, i.e. that have a tag with key "name" and value "Wuppertal".
</p>
</form>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
If you already know the id of your relation, you can use instead the following to find conflicts:
<textarea name="data" rows="3" cols="80">&lt;id-query type="relation" ref="62478"/&gt;
&lt;report/&gt;
</textarea>
<input type="submit" value="Find Conflicts"/>
<br/>
</p>
</form>

<p>
We give a short overview of the used statement: the query <a href="#section.query">&lt;query type="relation"&gt;&lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;&lt;/query&gt;</a> searches for relations (this is specified by the parameter type) that have a tag with key "name" and value "Wuppertal, Stadt" (this condition is specified by the tag <a href="#section.query">&lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;</a>. A full explanation of the quite versatile syntax of the query statement can be found in <a href="#section.query">its documentation</a>. The <a href="#section.id_query">&lt;id-query type="relation" ref="62478"/&gt;</a> by contrast finds the single relation with id 62478 as specified by the parameter ref. Both store their result into the <a href="#section.variables">default set</a> because there is no other set specified. Then, the statement <a href="#section.report">&lt;report/&gt;</a> prints to the user all conflicts that are related to an item in its input, again the <a href="#section.variables">default set</a>. It doesn't change any values in the query. Alternatively, the <a href="#section.print">&lt;print mode="body"/&gt;</a> simply prints the entire content of the <a href="#section.variables">default set</a>.
</p>

<div>
<a id="section.rule_example"/>
<h3>Declare a new type of area</h3>
</div>

<p>
Not all relations that refer to ways give automatically rise to a relation. The server recognizes a certain relation (or any other designated set of ways) as an area if a <a href="#section.queries_rules">rule</a> matches this relation or set of ways. The amazing thing is that you (or anybody else) can <a href="#section.add_rule">add</a> rules or <a href="#section.update_rule">change</a> the existing ones. Now assume that you want to designate all relations with a tag with key "foo" and value "bar" to represent areas.
</p>

<form action="api/get_rule" method="post" accept-charset="UTF-8">
<p>
You can <a href="#section.get_rule">retrieve</a> an existing rule to get a blueprint for our new rule. For example, the following query will return the rule that creates areas from administrative units:
<textarea name="data" rows="2" cols="80">&lt;osm-script name="Area::Create_from_admin_level"/&gt;
</textarea>
<input type="submit" value="Retrieve rule"/>
<br/>
This will give you a result like the following:
</p>
<pre><code>
&lt;osm-script name="Area::Create_from_admin_level" version="1"&gt;

&lt;query type="relation"&gt;
  &lt;has-kv k="admin_level"/&gt;
  &lt;has-kv k="name"/&gt;
&lt;/query&gt;
&lt;foreach into="rel"&gt;
  &lt;union&gt;
    &lt;recurse type="relation-way" from="rel"/&gt;
    &lt;recurse type="way-node"/&gt;
  &lt;/union&gt;
  &lt;make-area pivot="rel" into="odd"/&gt;
  &lt;detect-odd-nodes into="odd"/&gt;
  &lt;foreach from="odd" into="i"&gt;
    &lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;
    &lt;conflict&gt;In &lt;item set="rel"/&gt;, the &lt;item set="i"/&gt; is contained in an odd number of segments.&lt;/conflict&gt;
  &lt;/foreach&gt;
&lt;/foreach&gt;

&lt;/osm-script&gt;
</code></pre>
</form>

<form action="api/add_rule" method="post" accept-charset="UTF-8">
<p>
We take the following modifications: In the first line, we replace the <a href="#section.osm_script">name</a> of the rule by a new, descriptive name because we are adding a new rule. We remove the <a href="#section.osm_script">version tag</a> because this will be chosen by the server. Then, we replace the two lines starting with <a href="#section.query">has-kv</a> by a single line that describes the designation for the relations in question. Then we post the new rule to <a href="#section.add_rule">add_rule</a>:
<textarea name="data" rows="21" cols="80">&lt;osm-script name="Example::Foo"&gt;

&lt;query type="relation"&gt;
  &lt;has-kv k="foo" v="bar"/&gt;
&lt;/query&gt;
&lt;foreach into="rel"&gt;
  &lt;union&gt;
    &lt;recurse type="relation-way" from="rel"/&gt;
    &lt;recurse type="way-node"/&gt;
  &lt;/union&gt;
  &lt;make-area pivot="rel" into="odd"/&gt;
  &lt;detect-odd-nodes into="odd"/&gt;
  &lt;foreach from="odd" into="i"&gt;
    &lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;
    &lt;conflict&gt;In &lt;item set="rel"/&gt;, the &lt;item set="i"/&gt; is contained in an odd number of segments.&lt;/conflict&gt;
  &lt;/foreach&gt;
&lt;/foreach&gt;

&lt;/osm-script&gt;
</textarea>
<input type="submit" value="Add sample rule"/>
<br/>
You should recieve a message that the rule has successfully been added along with its new version number. If you recieve a the error that a rule with this name already exists, you have probably not changed the name in the above rule (and another guy already has left this example in the rule base).
</p>
</form>

<form action="api/update_rule" method="post" accept-charset="UTF-8">
<p>
To avoid cluttering the server, please complete this tutorial with removing your rule. Just call <a href="#section.update_rule">update_rule</a> with the empty rule and the parameter <a href="#section.osm_script">replace</a> set to the version number just recieved:
<textarea name="data" rows="2" cols="80">&lt;osm-script name="Example::Foo" replace="0"/&gt;
</textarea>
<input type="submit" value="Delete rule"/>
<br/>
You should recieve a message that the rule has successfully been updated.
</p>
</form>

<form action="api/get_rule" method="post" accept-charset="UTF-8">
<p>
If you recieve the error that you should provide the last version-id, then call again <a href="#section.get_rule">get_rule</a> on you rule:
<textarea name="data" rows="2" cols="80">&lt;osm-script name="Example::Foo"/&gt;
</textarea>
<input type="submit" value="Retrieve rule"/>
<br/>
The result contains the correct version number.
</p>
</form>

<p>
We conclude by explaining the statements in the rule "Area::Create_from_admin_level": The first line <a href="#section.osm_script">&lt;osm-script name="Area::Create_from_admin_level" version="1"&gt;</a> is an explicit statement of the <a href="#section.osm_script">root element</a> because a rule <a href="#section.queries_rules">needs always</a> a name and the name is provided as parameter of the root element. The <a href="#section.osm_script">version tag</a> is added by the server to indicate which version of the rule it has returned - in our example the most recent version which is by incidence 1.
</p>

<p>
The first executable statement in the rule is the query-block <a href="#section.query">&lt;query type="relation"&gt;&lt;has-kv k="admin_level"/&gt;&lt;has-kv k="name"/&gt;&lt;/query&gt;</a>. This query-block searches for relations as specified by the parameter "type". It returns only relations that have a tag with key "admin_level" and a tag with key "name". For both tags, any values match the search criteria as there are no values specified in the <a href="#section.query">has-kv</a> tags. The results of the query are stored into the <a href="#section.variables">default set</a>. A detailed description of the query syntax can be found in <a href="#section.query">its documentation</a>.
</p>

<p>
The <a href="#section.foreach">&lt;foreach into="rel"&gt;</a> statement regulates the <a href="#section.control_flow">control flow</a>: The body is executed once for each element in the input set. As there is no input set specified, the input is taken from the <a href="#section.variables">default set</a>. The output set "rel" contains during each loop solely the respective element from the input set.
</p>

<p>
The <a href="#section.foreach">foreach</a>-body starts with an <a href="#section.union">union</a>-block, containing the two statements <a href="#section.recurse">&lt;recurse type="relation-way" from="rel"/&gt;</a> and <a href="#section.recurse">&lt;recurse type="way-node"/&gt;</a>. The first one sets the <a href="#section.variables">default set</a> to the set of all ways that are members of the relation in the input set "rel". The second sets the <a href="#section.variables">default set</a> to the set of all nodes that are referred by ways from the <a href="#section.variables">default set</a>. Because of the <a href="#section.union">union</a>-block wrapped around, the <a href="#section.variables">default set</a> contains afterwards the ways that are members of the relation and their associated nodes.
</p>

<p>
The statement <a href="#section.make_area">&lt;make-area pivot="rel" into="odd"/&gt;</a> now creates the area: It takes input from two different sets. The first one not specified, thus being the <a href="#section.variables">default set</a>, contains the ways and nodes that decribe the spatial extent of the area; it contains any point that is separated from the south pole by an odd number of way segments. The second input set is specified by the <a href="#section.make_area">pivot</a> parameter. It should contain exactly one element, and the set "rel", set by <a href="#section.foreach">foreach</a>, does so. The area's <a href="#section.data_structures">id and tags</a> are derived from this element. The output of <a href="#section.make_area">make-area</a> is the created area if any. It is simultanenously written to the output set as well as the <a href="#section.data_structures">database of derived data</a>. The set is in our case redirected to the set "odd" as we don't need the area anymore.
</p>

<p>
The <a href="#section.detect_odd_nodes">&lt;detect-odd-nodes into="odd"/&gt;</a> statement detects nodes that appear an odd times as starting or end points of a way. These nodes are exactly the nodes that prevent <a href="#section.make_area">make-area</a> from making an area. The <a href="#section.detect_odd_nodes">detect-odd-nodes</a> statement takes its input from the <a href="#section.variables">default set</a> because there is no other set specified. The default set still contains the ways and nodes to produce an area from. The odd nodes are returned into the specified output set "odd".
</p>

<p>
The <a href="#section.foreach">&lt;foreach from="odd" into="i"&gt;</a> statement <a href="#section.control_flow">loops</a> over these nodes, which are stored in the input set "odd". Each node is during one loop available as content of the set "i". In the loop, the line <a href="#section.union">&lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;</a> sets the <a href="#section.variables">default set</a> to the node of the inner loop and the relation from the outer loop: The <a href="#section.item">&lt;item set="i"/&gt;</a> statement returns the content of the set "i" as output, hence the node of the current inner loop. The <a href="#section.item">&lt;item set="rel"/&gt;</a> returns the set "rel" that contains the relation of the current outer loop.
</p>

<p>
Finally, the line <code><a href="#section.conflict">&lt;conflict&gt;</a>In <a href="#section.conflict">&lt;item set="rel"/&gt;</a>, the <a href="#section.conflict">&lt;item set="i"/&gt;</a> is contained in an odd number of segments.<a href="#section.conflict">&lt;/conflict&gt;</a></code> writes the conflict message into the database for the elements of the current inner and current outer loop. It obtains these elements from its input set, the <a href="#section.variables">default set</a>. In the conflict message, the subtags <a href="#section.conflict">&lt;item set="rel"/&gt;</a> and <a href="#section.conflict">&lt;item set="i"/&gt;</a> are replaced by their contents. The <a href="#section.conflict">conflict</a> statement does not return anything. Then the rule continues with another inner loop or outer loop respectively.
</p>

<!-- ==================================================================== //-->

<div>
<a id="chapter.interface_calls"/>
<h2>Interface Calls</h2>
</div>

<p>
<a href="#section.interpreter">/api/interpreter</a><br/>
<a href="#section.get_rule">/api/get_rule</a><br/>
<a href="#section.add_rule">/api/add_rule</a><br/>
<a href="#section.update_rule">/api/update_rule</a><br/>
</p>

<div>
<a id="section.interpreter"/>
<h3>/api/interpreter</h3>
</div>

<p>
This is the API call to send a <a href="#section.queries_rules">query</a>, i.e. a request that returns the desired part of the OSM data. Some examples for queries are explained in "<a href="#section.reverse_gazetteer">To which country belongs this location?</a>", "<a href="#section.download_area">Download an entire city</a>" or "<a href="#section.debug_area">Why doesn't my city appear?</a>". The exact <a href="#chapter.input_formats">possibilities of formatting input</a> are explained in the chapter "<a href="#chapter.input_formats">Input Formats</a>". The <a href="#section.static_feedback">possible errors</a> and the <a href="#section.payload">output format</a> are explained in the chapter "<a href="#chapter.output_formats">Output Formats</a>".
</p>

<div>
<a id="section.get_rule"/>
<h3>/api/get_rule</h3>
</div>

<p>
This API call returns the source code of an existing <a href="#section.queries_rules">rule</a>. An example how to use this API call can be found in "<a href="#section.rule_example">Declare a new type of area</a>". To use this call you must <a href="#chapter.input_formats">send a request</a> that consists only of the <a href="#section.osm_script">root element</a>, with proper values for the attribute <a href="#section.osm_script">name</a> and maybe a value for the attribute <a href="#section.osm_script">version</a>. The returned data is a plain XML document without any compression.
</p>

<div>
<a id="section.add_rule"/>
<h3>/api/add_rule</h3>
</div>

<p>
This API call adds a new <a href="#section.queries_rules">rule</a>. An example how to use this API call can be found in "<a href="#section.rule_example">Declare a new type of area</a>". To use this call you must <a href="#chapter.input_formats">send a request</a> that containes the rule. This means in particular that you must specify the attribute <a href="#section.osm_script">name</a> of the <a href="#section.osm_script">root element</a>. The returned data is a plain XHTML document without any compression and tells you whether <a href="#section.status_remarks">the rule has been added</a> or <a href="#section.static_feedback">why it hasn't been added</a>.
</p>

<div>
<a id="section.update_rule"/>
<h3>/api/update_rule</h3>
</div>

<p>
This API call updates an existing <a href="#section.queries_rules">rule</a>. An example how to use this API call can be found in "<a href="#section.rule_example">Declare a new type of area</a>". To use this call you must <a href="#chapter.input_formats">send a request</a> that containes the new source code of the rule. This means in particular that you must specify the attributes <a href="#section.osm_script">name</a> and <a href="#section.osm_script">replace</a> of the <a href="#section.osm_script">root element</a>. <em>Name</em> must match the name of the exsiting rule and <em>replace</em> must match the <a href="#section.queries_rules">version</a> of the existing rule. This is a protection against accidently overwriting a rule. You can always obtain the current version number of a rule by a call to <a href="#section.get_rule">/api/get_rule</a>. The returned data is a plain XHTML document without any compression and tells you whether <a href="#section.status_remarks">the rule has been updated</a> or <a href="#section.static_feedback">why it hasn't been added</a>.
</p>

<!-- ==================================================================== //-->

<div>
<a id="chapter.statements"/>
<h2>Statements</h2>
</div>

<p>
<a href="#section.area_query">area-query</a><br/>
<a href="#section.bbox_query">bbox-query</a><br/>
<a href="#section.conflict">conflict</a><br/>
<a href="#section.coord_query">coord-query</a><br/>
<a href="#section.detect_odd_nodes">detect-odd-nodes</a><br/>
<a href="#section.foreach">foreach</a><br/>
<a href="#section.id_query">id-query</a><br/>
<a href="#section.item">item</a><br/>
<a href="#section.make_area">make-area</a><br/>
<a href="#section.osm_script">osm-script</a><br/>
<a href="#section.print">print</a><br/>
<a href="#section.query">query</a><br/>
<a href="#section.recurse">recurse</a><br/>
<a href="#section.report">report</a><br/>
<a href="#section.union">union</a><br/>
</p>

<div>
<a id="section.area_query"/>
<h3>area-query</h3>
</div>

<div>
<a id="subsection.area_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>ref</strong>: the <a href="#section.data_structures">id of the area</a> to consider.</li>
</ul>

<div>
<a id="subsection.area_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.area_query.description"/>
<h4>Description</h4>
</div>

<p>
The area-query returns all nodes that have coordinates within the provided area. A node is considered to be within an area if it is in the interior or on the boundary of an area. The nodes are stored in the set specified by "into". The area is selected by providing the <a href="#section.data_structures">id</a> of the area to the argument "ref".
</p>

<div>
<a id="subsection.area_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.area_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.bbox_query"/>
<h3>bbox-query</h3>
</div>

<div>
<a id="subsection.bbox_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>n</strong>: the northern limit of the bbox, provided as latitude.</li>
<li><strong>s</strong>: the southern limit of the bbox, provided as latitude.</li>
<li><strong>w</strong>: the western limit of the bbox, provided as longitude.</li>
<li><strong>e</strong>: the eastern limit of the bbox, provided as longitude.</li>
</ul>

<div>
<a id="subsection.bbox_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.bbox_query.description"/>
<h4>Description</h4>
</div>

<p>
The bbox-query returns all nodes that have coordinates within the provided bbox. A node is considered to be within the bbox if it is in the interior or on the boundary of the bbox. The nodes are stored in the set specified by "into".
</p>

<div>
<a id="subsection.bbox_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.bbox_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.conflict"/>
<h3>conflict</h3>
</div>

<div>
<a id="subsection.conflict.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.conflict.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.conflict.description"/>
<h4>Description</h4>
</div>

<p>
The conflict statement tags permanently (until the next rule application) one or more objects in the database as being invoked into a conflict. It is intended to be used in rules to mark objects that should be reviewed by a human in the context of the rule. The statement composes from the text and the <a href="#section.item">item</a> subelements within the element a message that should describe the conflict. Every object contained int the input set as specified by the parameter from is then tagged with this message. The messages for a given object can at any instant afterwards be query with the <a href="#section.report">report</a> statement.
</p>

<div>
<a id="subsection.conflict.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.conflict.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.coord_query"/>
<h3>coord-query</h3>
</div>

<div>
<a id="subsection.coord_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>lat</strong>: a valid latitude on earth, i.e. a floating point number between -90.0 and 90.0. It is evaluted with a precision of 10<sup>-7</sup> degrees.</li>
<li><strong>lon</strong>: a valid longitude on earth, i.e. a floating point number between -180.0 and 180.0. It is evaluted with a precision of 10<sup>-7</sup> degrees.</li>
</ul>

<div>
<a id="subsection.coord_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.coord_query.description"/>
<h4>Description</h4>
</div>

<p>
This statement returns as the set specifed by "into" all areas that cover the location on earth specified by the coordinates lat and lon. An area is also returned if the given location lies on its boundary.
</p>

<div>
<a id="subsection.coord_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.coord_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.detect_odd_nodes"/>
<h3>detect-odd-nodes</h3>
</div>

<div>
<a id="subsection.detect_odd_nodes.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.detect_odd_nodes.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.detect_odd_nodes.description"/>
<h4>Description</h4>
</div>

<p>
This statements detects in a set of ways all nodes that appear odd times as a endpoint. For a couple of tasks like the <a href="#section.area_query">derivation of an area</a> from a set of ways, an essential precondition is that the ways fit together. Fitting together means in this context that there is no junction of an odd number of segments at any node, because it that case, it is not well-defined which points of that polygon are inner and which not. Inner nodes of a way are always adjacent to two segments within that way so that they can be ignored. The statement takes the ways from the set specified by the argument "from" and puts the detected nodes into the argument "into".
</p>

<div>
<a id="subsection.detect_odd_nodes.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.detect_odd_nodes.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.foreach"/>
<h3>foreach</h3>
</div>

<div>
<a id="subsection.foreach.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.foreach.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.foreach.description"/>
<h4>Description</h4>
</div>

<p>
The foreach statement executes the sequence of its inner elements once for each element in the set specified by the argument "from". In particular, the set specified by the argument "from" will be stored on an internal stack. Then, for each element in the set specified by the argument "from", the following things will happen: first, the set specified by the argument "into" will be set to contain solely the element the loop is dedicated to. Then, the statements in the loop are executed. Finally, the server continues with the next loop. The order of the indivdual loops is unspecified, only the order within a loop adheres to the order in the source code.
</p>

<div>
<a id="subsection.foreach.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.foreach.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.id_query"/>
<h3>id-query</h3>
</div>

<div>
<a id="subsection.id_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation", "way" or "node".</li>
<li><strong>ref</strong>: the <a href="#section.data_structures">id</a> of the object to consider.</li>
</ul>

<div>
<a id="subsection.id_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.id_query.description"/>
<h4>Description</h4>
</div>

<p>
This statement queries the database for the single object of the specified type and with the specified id. It returns as the set specified by the argument "into" the set consisting of this object or an empty set if the object doesnt exist.
</p>

<div>
<a id="subsection.id_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.id_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.item"/>
<h3>item</h3>
</div>

<div>
<a id="subsection.item.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.item.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>set</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.item.description"/>
<h4>Description</h4>
</div>

<p>
The item statement declares its argument as output. This is used within the <a href="#section.union">union</a> statement and the <a href="#section.conflict">conflict</a> statement to refer to an existing set.
</p>

<div>
<a id="subsection.item.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.item.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.make_area"/>
<h3>make-area</h3>
</div>

<div>
<a id="subsection.make_area.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>pivot</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.make_area.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.make_area.description"/>
<h4>Description</h4>
</div>

<p>
This statement creates an area from a multipolygon, writes this area into the database and returns this area as output. From a general mathematical point of view, one can define an area from its boundary as follows: you fix the boundary and a single point that is outside the area. Then a point is outside if and only if any curve to the outside point crosses an even number of segments. We use this definition and take as the outside point always the south pole and the set of ways in the input set (specified by the argument "from") as boundary. The make-area statement now requires that the input set contains all nodes that are referred by at least one way in the set. Furthermore, it requires that the ways fit together. This means that any node is referred by an even number of segments. Otherwise there would be a boundary with interior or the exterior on both sides. The area then consists of all points such that you have to cross an odd number of segments to reach the south pole. The area is tagged with all tags from the pivot element and obtains its <a href="#section.data_structures">id</a> as follows:
</p>
<ul>
<li>An area based on a node has the same id as the node.</li>
<li>An area based on a way has the the id of the way plus 2,400,000,000.</li>
<li>An area based on a relation has the id of the relation plus 3,600,000,000.</li>
</ul>
<p>
The statement finally returns as the output set specified by "into" the set consisting of the newly created area. If a precondition fails, it writes nothing to the database, produces a <a href="#section.status_remarks">status remark</a> and returns the empty set.
</p>

<div>
<a id="subsection.make_area.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.make_area.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.osm_script"/>
<h3>osm-script</h3>
</div>

<div>
<a id="subsection.osm_script.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.osm_script.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>timeout</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): a nonnegative integer describing an amount of seconds.</li>
<li><strong>element-limit</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): a nonnegative integer describing a limit for element usage.</li>
<li><strong>debug</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): one of the values "quiet", "errors", "verbose" or "static". It defaults to "errors".</li>
<li><strong>name</strong> (only with <a href="#section.get_rule">/api/get_rule</a>, <a href="#section.add_rule">/api/add_rule</a> or <a href="#section.update_rule">/api/update_rule</a>): an arbitrary string describing an identifier for a rule.</li>
<li><strong>version</strong> (only with <a href="#section.get_rule">/api/get_rule</a>): the version id of the rule.</li>
<li><strong>replace</strong> (only with <a href="#section.update_rule">/api/update_rule</a>): the version id of the rule to replace.</li>
</ul>

<div>
<a id="subsection.osm_script.description"/>
<h4>Description</h4>
</div>

<p>
This is the root element of all queries and rules. You <a href="#chapter.input_formats">may omit</a> this element if you don't need to provide an explicit argument. Which arguments are useful depends on whether you write a <a href="#section.queries_rules">query</a> or a <a href="#section.queries_rules">rule</a>.
</p>

<p>
The parameters "timeout" and "element-limit" are used to <a href="#section.quotas">assert</a> that a query has a reasonable ressource consumption. It is only necessary if the <a href="#section.flow_forecast">flow forecast</a> can't predict a modest ressource consumption directly. If the query exceeds its asserted limits, it will be aborted. The parameter "debug" controls how much meta information is included: if it is set to "quiet", no meta information will be added. If it is set to "errors", it displays only errors. If it is set to "verbose", it shows all the messages explained in <a href="#section.status_remarks">Status Remarks</a>. If it is set to "static", it won't run the query but display the <a href="#section.static_feedback">flow forecast</a> for this query.
</p>

<p>
For a rule, the parameter "name" provides the name of the rule. It is used to <a href="#section.add_rule">add</a> a rule or to <a href="#section.update_rule">update</a> an existing one, as well as to <a href="#section.get_rule">query</a> a rule. The parameter "version" tells you which <a href="#section.queries_rules">version</a> a given rule has. As a safety measure, if you intent want to update a rule, you need to specify by the "replace" parameter the version of the rule to replace.
</p>

<div>
<a id="subsection.osm_script.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.osm_script.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.print"/>
<h3>print</h3>
</div>

<div>
<a id="subsection.print.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.print.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>mode</strong>: one of the values "ids_only", "skeleton" or "body". If it is omitted, it defaults to "skeleton".</li>
</ul>

<div>
<a id="subsection.print.description"/>
<h4>Description</h4>
</div>

<p>
The statement prints the content of its input set specified by "from" into the response document. The output contains only the objects' ids if mode is set to "ids_only". It contains the ids, the coordinates of nodes and the members of ways and relations if mode is set to "skeleton". It contains all the information about the objects including their tags if the mode is set to "body".
</p>

<div>
<a id="subsection.print.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.print.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.query"/>
<h3>query</h3>
</div>

<div>
<a id="subsection.query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation", "way" or "node".</li>
</ul>

<div>
<a id="subsection.query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.query.description"/>
<h4>Description</h4>
</div>

<p>
The query statement finds all objects of the specified type that have all the provided tags. The search criteria is formulated with one or more subelements of the form <code>&lt;has-kv k="foo" v="bar"/&gt;</code> or <code>&lt;has-kv k="foo"/&gt;</code>. The strings "foo" and "bar" should be replaced by the respective tags to search for. The former element restricts the result to objects that have a tag with the given key and the given value, the latter element restricts the result to objects that have a tag with the given key and arbitrary value.
</p>

<div>
<a id="subsection.query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.recurse"/>
<h3>recurse</h3>
</div>

<div>
<a id="subsection.recurse.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation-relation", "relation-backwards", "relation-way", "relation-node", "way-node", "way-relation", "node-relation" or "node-way"</li>
</ul>

<div>
<a id="subsection.recurse.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.recurse.description"/>
<h4>Description</h4>
</div>

<p>
The statement deduces from all nodes, ways or relations in the input set the referred nodes, ways or relations and returns them into the output set. Depending on the value of "type", the statement behaves as follows:
</p>
<ul>
<li><strong>relation-relation</strong>: The statement returns all relations that are members of at least one relation from the input set.</li>
<li><strong>relation-way</strong>: The statement returns all ways that are members of at least one relation from the input set.</li>
<li><strong>relation-node</strong>: The statement returns all nodes that are members of at least one relation from the input set.</li>
<li><strong>relation-backwards</strong>: The statement returns every relation that refers to at least one relation from the input set as a member.</li>
<li><strong>way-node</strong>: The statement returns all nodes that are members of at least one way from the input set.</li>
<li><strong>way-relation</strong>: The statement returns every relation that refers to at least one way from the input set as a member.</li>
<li><strong>node-relation</strong>: The statement returns every relation that refers to at least one node from the input set as a member.</li>
<li><strong>node-way</strong>: The statement returns every way that refers to at least one node from the input set as a member.</li>
</ul>

<div>
<a id="subsection.recurse.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.recurse.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.report"/>
<h3>report</h3>
</div>

<div>
<a id="subsection.report.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.report.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.report.description"/>
<h4>Description</h4>
</div>

<p>
The statement queries the database for conflicts recorded by the <a href="#section.conflict">conflict</a> statement. It prints all conflicts that are related to any object in the set specified by "from" into the response document. If there is no <a href="#section.print">print</a> statement in the query, the output is formatted as <a href="#section.hypertext_reports">hypertext report</a>.
</p>

<div>
<a id="subsection.report.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.report.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.union"/>
<h3>union</h3>
</div>

<div>
<a id="subsection.union.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.union.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.union.description"/>
<h4>Description</h4>
</div>

<p>
The union statement collects the output sets of its subelements and returns them as the set specified by "into". For each statement, the output set is the set specified by the parameter "into" or the empty set if the statement has no parameter "into". The only exception from this rule is the <a href="#section.item">item</a> statement. This statement designates its output set by its sole argument "set".
</p>

<div>
<a id="subsection.union.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.union.examples"/>
<h4>Examples</h4>
</div>

<!-- ==================================================================== //-->

<div>
<a id="chapter.concepts"/>
<h2>Concepts</h2>
</div>

<p>
<a href="#section.data_structures">Data structures</a><br/>
<a href="#section.queries_rules">Queries and Rules</a><br/>
<a href="#section.control_flow">Control Flow</a><br/>
<a href="#section.variables">Variables</a><br/>
<a href="#section.other_sets">Other Sets in Scripts</a><br/>
<a href="#section.flow_forecast">Flow Forecast</a><br/>
<a href="#section.quotas">Limits and Quotas</a><br/>
<a href="#section.database_layout">Database Layout</a><br/>
</p>

<div>
<a id="section.data_structures"/>
<h3>Data structures</h3>
</div>

<p>
OSM Server Side Script adheres to the data structure of the <a href="http://wiki.openstreetmap.org/wiki/API">OSM main database</a> as close as possible, but there are differences. This server is intended to respond to advanced queries for spatial data as fast as possible. It does neither provide a possibility to edit data nor the community support features of the <a href="http://wiki.openstreetmap.org/wiki/API">OSM main database</a>. The server mirrors the <a href="http://wiki.openstreetmap.org/wiki/Elements">spatial elements</a> from the OSM main database: <strong>nodes</strong> with their ids and tags, <strong>ways</strong> with their ids, members and tags and <strong>relations</strong> with their ids, members, roles and tags. The ids for the <a href="http://wiki.openstreetmap.org/wiki/Elements">elements</a> are the same as in the <a href="http://wiki.openstreetmap.org/wiki/API">OSM main database</a>.
</p>

<p>
Furthermore, the OSM Server Side Script server stores some useful derived data structures. At the moment, these are <strong>areas</strong> and <strong>conflicts</strong>.
</p>

<p>
<strong>Areas</strong> are stored with their id, their spatial extend and tags that describe them. The areas are derived by <a href="#section.queries_rules">user mutable rules</a> from the OSM data. Each area inherits its id and its tags from its pivot element. The tags are copied verbatim from the pivot element. The id is derived as follows:
</p>
<ul>
<li>An area based on a node has the same id as the node.</li>
<li>An area based on a way has the the id of the way plus 2,400,000,000.</li>
<li>An area based on a relation has the id of the relation plus 3,600,000,000.</li>
</ul>
<p>
Note that two different areas can't have the same pivot element.
</p>

<p>
<strong>Conflicts</strong> contain a message that a certain arrangement of <a href="http://wiki.openstreetmap.org/wiki/Elements">elements</a> does not meet the expectations set up by one or more <a href="#section.queries_rules">rule</a>. They consist of a message and they are attached to the nodes, ways and relations that are in conflict with the rule. They are generated by a <a href="#section.conflict">conflict</a> statement within a rule. They can be retrieved by the <a href="#section.report">report</a> statement.
</p>

<p>
The following data structures that appear in the <a href="http://wiki.openstreetmap.org/wiki/API_v0.6">current API</a> of the OSM main database aren't stored here: we don't store timestamps, versions, changesets, any user information or historical data, i.e. deleted elements or old versions of updated elements.
</p>

<div>
<a id="section.queries_rules"/>
<h3>Queries and Rules</h3>
</div>

<p>
The servers deals with two different pieces of OSM Server Side Script source code. The first are <strong>queries</strong>, the second are <strong>rules</strong>. Both are called <strong>scripts</strong>.
</p>

<p>
A <strong>query</strong> is sent to the OSM Server Side Script server by a client to retrieve data. Currently, the only useful method for this is via the <a href="#section.interpreter">interpreter</a> API call. The query will then, if possible, be executed, and any output is sent back to the client.
</p>

<p>
Feel free to boldly experiment with <strong>queries</strong>. The entire system is designed to prevent runaway queries: your query will be <a href="#section.flow_forecast">analysed</a> before it is processed. If it exceeds the <a href="#section.quotas">time or space limit</a> of 3 minutes or 10,000,000 element equivalents as explained <a href="#section.quotas">below</a>, you will recieve a <a href="#section.static_feedback">flow forecast warning</a>. You can override this safety stop by manually setting the <a href="#section.osm_script">timeout</a> or <a href="#section.osm_script">element limit</a>. <em>If you don't get a response from the server within three minutes although you have not set a manual override, this is an error of the server.</em> Please contact in this case the server admin via the email adress <em>osm3s.admin</em>&nbsp;AT&nbsp;<em>lokove.de</em> and attach your query.
</p>

<p>
A <strong>rule</strong> is processed by the OSM Server Side Script server to generate derived data. For example, the rule that generates the areas based on administrative boundaries is discussed in <a href="#section.rule_example">this</a> section of the <a href="#chapter.use_cases">Use Cases</a> chapter. Rules can be manipulated by every user via the following API calls: First, you can retrieve rules by <a href="#section.get_rule">/api/get_rule</a>. Furthermore, you can add completely new rules by <a href="#section.add_rule">/api/add_rule</a>. Finally, you can change existing rules by <a href="#section.update_rule">/api/update_rule</a>. Note that the rules behave monotoneously. Thus, by adding an additional rule, you can let the server generate additional derived data. But you can never change existing derived data unless you edit an existing rule.
</p>

<p>
Existing <strong>rules</strong> are uniquely identified by their <em>name</em> and protected by their <em>version number</em> against accidental edits. You need to explicitly specify the existing rule version as version to replace (as explained at the <a href="#section.update_rule">update_rule</a> API call) to change the rule. The rules are executed in ascending order of their version numbers, and of every rule only the most recent version (the version with biggest version number) is executed.
</p>

<div>
<a id="section.control_flow"/>
<h3>Control Flow</h3>
</div>

<p>
For <a href="#section.queries_rules">queries</a>, there are two stages: first, a query is <a href="#section.flow_forecast">analysed</a>, then it is executed. Rules are executed without prior analysis. We will discuss in the following section the execution, the analysis will be discussed in the section <a href="#section.flow_forecast">Flow Forecast</a>.
</p>

<p>
Basically, the scripts are executed line by line. Additionally, there is the <a href="#section.foreach">foreach</a> statement: this statement allows to loop over all the elements of a given set. Note that this is designed to terminate always: the behaviour of a <a href="#section.foreach">foreach</a> statement does only depend on the contents of the set when the control flow arrives at the loop. A change of the set during the loop does not affect the behaviour of the <a href="#section.foreach">foreach</a> statement. Thus, you can never produce a infinitely running program.
</p>

<p>
The server might do optimizations if they are semantically equivalent. This can change the control flow. For example, in a <a href="#section.query">query</a> statement the order of the <a href="#section.query">has-kv</a> substatements will be changed to apply the most restrictive condition first to speed up the query.
</p>

<div>
<a id="section.variables"/>
<h3>Variables</h3>
</div>

<p>
The handles on a particular piece of <a href="#section.data_structures">OSM data</a> are the variables. They serve to transmit subsets of OSM data between different statements of a <a href="#section.queries_rules">script</a>. Each variable represents a set that can contain any number of nodes, ways, relations and/or areas. The content of a variable can change during every execution of a statement in the script, depending on the <a href="#chapter.statements">semantics</a> of the respective statement.
</p>

<p>
<strong>Names for variables</strong> may be every string that is valid XML. The variable with name "_" has a special function and is called <strong>default set</strong>: Most statements take input, produce output or both. To specify which set of OSM data to take as input or where to save output into, you normally must provide the name of the respective set as argument to "from" (for input) or "into" (for output). But most scripts need few different sets or even just one simultaneously. Thus, if you use most of the time only one set, you can give it the name "_" and omit the entire "from"- or "into"-parameter. For example, the statements <code>&lt;print from="_"/&gt;</code> and <code>&lt;print/&gt;</code> are semantically equivalent.
</p>

<p>
If you use in a statement as output variable an already previously used variable, the previous contents of the variable are replaced at the end of the statement's execution with the set formed by the output of the statement.
</p>

<div>
<a id="section.other_sets"/>
<h3>Other Sets in Scripts</h3>
</div>

<p>
Beside the variables, there is one further place where sets of OSM data are stored, the stack. The stack is used by the statements <a href="#section.foreach">foreach</a> and <a href="#section.union">union</a>.
</p>

<p>
The <a href="#section.foreach">foreach</a> statement stores on the stack during the execution of its body a copy of its pivot set, i.e. the set it loops through. The variable specified as output of the foreach set contains during each loop a set with a single element of the pivot set; there is exactly one loop for each element of the pivot set.
</p>

<p>
The <a href="#section.union">union</a> statement stores during its execution the union of all the output sets of its substatements. This set is finally assigned to the variable specified by the "into"-parameter of the union statement.
</p>

<p>
Both sets are taken into account by the <a href="#section.flow_forecast">Flow Forecast</a> when counting the element equivalents for the element limit.
</p>

<div>
<a id="section.flow_forecast"/>
<h3>Flow Forecast</h3>
</div>

<p>
The Flow Forecast should prevent the following two situations: first that the server crashes due to heavy load, second that a complex query runs for hours and block the server's ressources although the client has already gone away. The Flow Forecast is a static analysis that will be taken of every <a href="#section.queries_rules">query</a> before the query is executed. If the static analysis gives rise to doubts that the query can run with modest ressource comsuption, the query is not executed and the client gets back the <a href="#section.static_feedback">results of the analysis</a>. The ressource limits are explained in the <a href="#section.quotas">next</a> section. Although we try to make a good prediction, the forecast may overestimate the needed ressources for a query in some cases. Thus, the Flow Forecast can be bypassed by setting the <a href="#section.osm_script">timeout</a> and/or <a href="#section.osm_script">element-limit</a> parameter in the <a href="#section.osm_script">root statement</a> of the query.
</p>

<p>
First, the <strong>control flow</strong> is predicted. In general, the server just follows the <a href="#section.control_flow">semantics</a> of the control flow of the individual statements and collects the meta information for the other estimations. In a <a href="#section.foreach">foreach</a> statement, the computations in the individual loops must be independent from each other. If this is the case, the foreach statement is investigated only once. Otherwise, the analysis will <a href="#section.static_feedback">result</a> in an error.
</p>

<p>
The <strong>time usage</strong> estimates the expected runtime of the script. This is done as follows: for each statement, an execution time is predicted when the control flow prediction arrives at this point. This prediction is based on the type of the statement and the number of elements in the <a href="#section.variables">involved sets</a>. In particular, this includes the <a href="#section.variables">output</a> of a statement. For example, a <a href="#section.query">query</a> statement may vary in its runtime very much. But it has only output. Thus, the size of the output set is the only handle to predict the runtime of this statement. For the sake of simplicity, the <a href="#section.database_layout">spatial distribution</a> of the data is not taken into account, only the estimated number of elements involved, discriminated between <a href="#section.data_structures">nodes, ways, relations and areas</a>.
</p>

<p>
The <strong>space usage</strong> estimates the expected memory usage of the query. The relevant number for this is the number of elements of <a href="#section.data_structures">each type</a> in the sets at the end of every statement. The amout of memory is derived from this by a weighted sum of the numbers of elements of different types: a node counts as a single element, a way counts as 10 elements and a relation counts as 20 elements. The estimation ends with an <a href="#section.static_feedback">error</a> if the weighted sum surpasses the memory threshold for a single query (currently 10,000,000 element equivalents). For <a href="#chapter.statements">statements</a> which produce only output, this estimation depends only on the statement's arguments. For <a href="#chapter.statements">statements</a> which derive their output from their input, the estimation for the size of the output sets depends on the size of the input sets.
</p>

<div>
<a id="section.quotas"/>
<h3>Limits and Quotas</h3>
</div>

<p>
Each query is subject to limits and quotas. This protects the server from getting overcrowded by runaway queries. On the other hand, the worries about ressource consumption should bother the normal user as fewly as possible. Thus, the ressource management of the OSM Server Side Script knows two ways of ressource management. A standard query is assessed by the <a href="#section.flow_forecast">Flow Forecast</a>. If this analysis accepts the query, no further restrictions apply to it.
</p>

<p>
A query with a <a href="#section.osm_script">manually set timeout</a> will be stopped by the server after the specified amount of time. There is no limit to the amount of time you can sepcify. If you set a manual timeout, please ensure that your client is waiting long enough. Some browsers or other clients cancel a request after 60, 120 or 180 seconds unless you configure them not to do so. If the server aborts a query, you will find the <a href="#section.status_remarks">error message</a> "Your query timed out". You may get this message after a partial response or along with other messages.
</p>

<p>
Slightly more complicated are the <strong>space restrictions</strong>. In general, the amount of elements which are in the server's RAM simultaneously is limited by the amount of RAM the server has. Thus, the <a href="#section.flow_forecast">element limit</a> of 10,000,000 element equivalents (these use roughly 500 MB of RAM) is a hard limit. You can <a href="#section.osm_script">assert</a> a lower limit, but not a higher limit. The server aborts the query if it grows to a bigger size than its limit.
</p>

<div>
<a id="section.database_layout"/>
<h3>Database Layout</h3>
</div>

<p>
The database is designed to serve complex spatial queries. Note that the OSM database is an extraordinary big database. Thus, the speed of almost all queries is limited by the speed of the server's harddisks. We cope with this problem by keeping data that is spatially related as closely to each other on the disk as possible. This is combined with a rather fine grained data structure. We will give you details to clarify which queries are fast and which are rather slow.
</p>

<p>
The data is split up into the skeleton and the tags. The skeleton consists for nodes of their id and coordinates, for ways and relations of their ids and the ids of their members. For nodes and ways, the storage of the skeleton data is organised with respect to the quadtiles they belong to. As relations don't have a spatial position, they are organised by id.
</p>

<p>
The data for the tags is organised again spatially in a separate table. But we take into account that keys and values often repeat frequently (like <code>highway=motorway</code>). This favors queries for generic tags like <code>highway=motorway</code> as well as for specific tags like <code>name=Elberfeld</code>. A query for a tag with may values as for example <code>name=*</code> will be comparably slow because it reads and compares large portions of the tag data.
</p>

<p>
Another effect of the splitting in skeleton and tag data is that a print query is significatly faster if it does not refer to tags. This is the reason for the "skeleton" and "ids_only" option of the <a href="#section.print">print</a> statement.
</p>

<p>
<strong>Areas</strong> and <strong>conflicts</strong> are currently stored in MySQL MyISAM tables. These are anyway rather small amounts of data and should not constitute a bottleneck.
</p>

<!-- ==================================================================== //-->

<div>
<a id="chapter.input_formats"/>
<h2>Input Formats</h2>
</div>

<p>
Basically, the input is a complete XML document with root element <a href="#section.osm_script">osm-script</a>. There is no formal DTD but the allowed elements are exactly the statements as explained in the <a href="#chapter.statements">statement</a> chapter of this manual. This includes for each statement its allowed subelements, called substatements in <a href="#chapter.statements">this</a> context, and tags, called parameters in <a href="#chapter.statements">this</a> context. The XML syntax is modified in two ways: To make input as brief as possible, you can omit some parts of the XML code. To make input as flexible as possible, you can encode the input in different manners. In the following sections, we explain both modifications in detail with the simple query <code>&lt;print mode="body"/&gt;</code>
</p>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
You can always omit the file type declaration. For example, the input
  <textarea name="data" rows="7" cols="80">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;osm-script&gt;

&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
<input type="submit" value="Return nothing"/>
</p>
</form>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
and the input
<textarea name="data" rows="6" cols="80">&lt;osm-script&gt;

&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
<input type="submit" value="Return nothing"/>
<br/>
are from the server's point of view equal.
</p>
</form>

<form action="api/interpreter" method="post" accept-charset="UTF-8">
<p>
If you don't need to specify any parameters in the <a href="#section.osm_script">root element</a>, you can even omit the root element itself. So, even the input
<textarea name="data" rows="2" cols="80">&lt;print mode="body"/&gt;
</textarea>
<input type="submit" value="Return nothing"/>
<br/>
is for the server the same input as the above examples.
</p>
</form>

<p>
We explain the different possible encodings. To make it possible to submit data via HTML forms, you can either send your data verbatim or prefix it by "<code>data=</code>" and escape all special characters to a sequence of a percent sign, followed by the value of the respective byte as hexdecimal number. Multi-byte characters should be expanded in a individual sequence for each byte. For example, the inputs
</p>
<pre><code>
&lt;print mode="body"/&gt;
</code></pre>
<p>
and
</p>
<pre><code>
data=%3Cprint%20mode=%22body%22/%3E
</code></pre>
<p>
and
</p>
<pre><code>
data=%3Cprint%20mode=%22body%22/%3E&amp;this_garbage_will_be_ignored
</code></pre>
<p>
and
</p>
<pre><code>
foo=bar&amp;data=%3Cprint%20mode=%22body%22/%3E&amp;this_garbage_will_be_ignored
</code></pre>
<p>
are equal. The transformation from the former to the latter is normally done by your browser or client program automatically or even from the users point of view unintentionally. So if you get a <a href="#section.static_feedback">encoding error</a>, try prefixing your query by "data=". The server tries to interpret your input verbatim if the first non-whitespace character found is a verbatim "&lt;", in all other cases it searches for a "data=" substring, takes and decodes the input from that position until the next verbatim "&amp;".
</p>

<p>
We explain the different possible encodings. You can send your data by a HTTP GET request as well as by a HTTP POST request, with precedence for the GET payload if you send both simultaneously. To continue the above example, the URL
</p>
<pre>  <a href="http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E">http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E</a></pre>
<p>
is equal to any of the above queries.
</p>

<p>
If you want to use the famous program wget to retrieve the data from the server, you can use any of the sample command lines
</p>
<pre><code>
wget -O - http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E | gunzip
</code></pre>
<p>
or
</p>
<pre><code>
wget -O - --post-data="data=%3Cprint%20mode=%22body%22/%3E" http://78.46.81.38/api/interpreter | gunzip
</code></pre>
<p>
or
</p>
<pre><code>
wget -O - --post-data="&lt;print mode=\"body\"/&gt;" http://78.46.81.38/api/interpreter | gunzip
</code></pre>
<p>
Note that in the third variant the quotation marks are escaped in the usual shell style. The output is piped into gunzip to make it visible as uncompressed XML. A more appropriate way for a longer query would be to save your query into a file, e.g. <code>foo.xml</code> and then use the command
</p>
<pre><code>
wget -O - --post-file=foo.xml http://78.46.81.38/api/interpreter | gunzip
</code></pre>

<!-- ==================================================================== //-->

<div>
<a id="chapter.output_formats"/>
<h2>Output Formats</h2>
</div>

<p>
<a href="#section.payload">Payload</a><br/>
<a href="#section.status_remarks">Status Remarks</a><br/>
<a href="#section.hypertext_reports">Hypertext Reports</a><br/>
<a href="#section.static_feedback">Static Error Feedback</a><br/>
</p>

<div>
<a id="section.payload"/>
<h3>Payload</h3>
</div>

<p>
If the query has been answered successfully, you will receive a gzip compressed XML document of MIME type "application/osm3s". It is, as specified by HTTP, announced with header "Content-Encoding: gzip". Thus, your client may uncompress the data before storing it.
</p>

<p>
The root-tag of the XML document is "osm-derived". Furthermore, each document contains an attribution note and, in the tag "meta", a timestamp and an information which rule was applied. The timestamp is the timestamp of the OSM data that has been used for the query.
</p>

<p>
In the remainder, you get the data your query produced. In general, these are nodes, way and relations in a similar syntax as the <a href="http://wiki.openstreetmap.org/wiki/API">OSM API</a> but without version, user data and timestamp. The <a href="#section.data_structures">areas</a> have the same syntax for tags as nodes, but they only have an id. Most likely, this is data from a <a href="#section.print">print</a> statement.
</p>

<div>
<a id="section.status_remarks"/>
<h3>Status Remarks</h3>
</div>

<p>
Basically, you can get three different types of runtime remarks, <strong>state remarks</strong>, <strong>runtime remarks</strong> or <strong>runtime errors</strong>.
</p>

<p>
The <strong>state remarks</strong> provide you with information about how much time a certain statement consumed and which output was produced by which statement. They are included if you set in the <a href="#section.osm_script">root statement</a> the parameter <code>debug</code> to <code>verbose</code>. They are tagged as <code>&lt;remark type="state"&gt;</code> and included after the termination of each statement. They contain a timestamp at what time they have finished, the statement's line number and the contents of the stack at that moment.
</p>

<p>
The <strong>runtime remarks</strong> inform you about important events that appeared during your request but that don't mean an error. At the moment, only the <a href="#section.add_rule">add_rule</a> and <a href="#section.update_rule">update_rule</a> api calls use this kind of remark to inform you that your request has been successful.
</p>

<p>
The <strong>runtime errors</strong> inform you about problems that definitely made your query to fail. The most common would be a <a href="#section.quotas">timeout</a> or <a href="#section.quotas">out of memory</a> error. But also a lot of unrecoverable database errors will be treated that way. Or ways that refer to nonexisiting nodes. In most of these cases you can't do much yourself, but please write an email to <em>osm3s.admin</em>&nbsp;AT&nbsp;<em>lokove.de</em>.
</p>

<div>
<a id="section.hypertext_reports"/>
<h3>Hypertext Reports</h3>
</div>

<p>
If your query contains only <a href="#section.report">report</a> statements as statements with output, the server answers your quey with a human readable HTML document. It contains  messages that have been generated by <a href="#section.conflict">conflict</a> statements during the rule computation. Each is presented in a paragraph. If the message contains nodes, there will be direct links to the respective location on the <a href="http://www.openstreetmap.org">OpenStreetMap.org</a> map.
</p>

<div>
<a id="section.static_feedback"/>
<h3>Static Error Feedback</h3>
</div>

<p>
The static error feedback will be displayed if the server can't make a feasible query out of your input. It consists of up to four sections, "Encoding Remarks", "Your input formatted for XML parsing", "Static Remarks" and "Flow Forecast". The later sections don't appear if in the earlier sections an error has been detected.
</p>

<p>
The section <strong>Encoding Remarks</strong> contains information how the server has extracted the input from the <a href="#chapter.input_formats">incoming data</a>. Details about the possible formats are explained in the chapter <a href="#chapter.input_formats">Input formats</a>. The server tells you whether it has found data by method GET (that means, it has found something that looks like data in the request URI) or uses data from PUT or has not found any data at all - this will be indicated as "only whitespace found". The next issue is the encoding: either your data starts with a "&lt;", or it is assumed to be CGI encoded. Again, the server tells you in this section what it assumes your data to be. The third thing that's detected automatically is whether your query has an explicit <a href="#section.osm_script">root statement</a> and DTD declaration. If no root statement or DTD declaration is found, the server adds one and tells you that it has done so.
</p>

<p>
The section <strong>Your input formatted for XML parsing</strong> consists of a pretty printed version of what the server has taken as input from the client. If this does not match your intended input, probably something has gone wrong during the <a href="#chapter.input_formats">input decoding</a>. If your input is properly displayed, the problem appears in a later step of processing. If there exists a static remark for a line, it is displayed in green and a link with letter "R" in parentheses is appended. If there exists a static error related to a certain line, the line is displayed in red and a link with letter "E" in parentheses is appended.
</p>

<p>
The section <strong>Static Remarks</strong> contains for a feasible query only remarks, no errors. The remarks contain information that might be useful for further analysis and do not indicate any trouble with the <a href="#section.queries_rules">script</a>. The errors indicate that your script is syntactically incorrect. There are errors that are common to most statements, errors which are specific for some statements and errors that appear only with <a href="#section.queries_rules">rules</a>.
</p>

<p>
The common and general errors include:
</p>
<ul>
<li><code>Unknown tag "</code>element<code>" in line "</code>line number<code>"!</code>: This means that the tag you try to use as statement is not a known <a href="#chapter.statements">name of a statement</a>. Please check if you have misspelled the tag.</li>
<li><code>Unknown attribute "</code>attribute<code>" in element "</code>element<code>".</code>: This means that you use an unknown attribute on a known <a href="#chapter.statements">statement</a>. Please check if you have misspelled the attribute name at the description of the respective <a href="#chapter.statements">statement</a>.</li>
<li><code>Element "</code>inner element<code>" cannot be subelement of element "</code>outer element<code>".</code>: For the most statements, only few statements make sense as substatements. Please read the <a href="#chapter.statements">description</a> of the outer <a href="#chapter.statements">statement</a> to determine which substatements are possible.</li>
<li><code>Element "</code>element<code>" must not contain text.</code>: Only very few statements like <a href="#section.conflict">conflict</a> accept text as subelement.</li>
<li><code>For the attribute "</code>attribute<code>" of the element "</code>element<code>" the only allowed values are</code> some description<code>.</code>: The possible value of some description varies with the statements and their attributes. <em>Some description</em> designates the class of allowed values. These can be a list of fixed values. Or it can be degrees of latitude or longitude, i.e. floats between -90.0 and 90.0 respective -180.0 and 180.0, e.g. in the <a href="#section.bbox_query">bbox-query</a> or <a href="#section.coord_query">coord-query</a> statement. Or it can be an id, i.e. a positive integer, e.g. in the <a href="#section.area_query">area-query</a> or <a href="#section.id_query">id-query</a> statement. Or it can be a nonempty string like in the <em>has-kv</em> substatement of a <a href="#section.query">query</a> statement. If you get this error although you haven't written the attribute in question, it will indicate that this attribute is mandatory.</li>
</ul>

<p>
There exist the following errors related to a specific statement:
</p>
<ul>
<li>For the <a href="#section.query">query</a> statement, <code>An area-query as substatement is only allowed for queries of type "node"</code>: You can restrict spatially the results of a query statement. But you can only restrict queries for nodes. For ways and relations, there is no clear notion of where they spatially belong to. Support for ways and relations will be added when a clear decision has been made by the <a href="http://www.openstreetmap.org">OpenStreetMap</a> community about semantics.</li>
<li>For the <a href="#section.query">query</a> statement, <code>A query statement may contain at most one area-query or bbox-query as substatement.</code>: You can restrict spatially the results of a query statement. But you can only use one spatial restriction per query statement.</li>
</ul>

<p>
You may get the following errors on the <a href="#section.osm_script">root element</a> if you perform another <a href="#chapter.interface_calls">interface call</a> than <a href="#section.interpreter">/api/interpreter</a>:
</p>
<ul>
<li>For the <a href="#section.add_rule">/api/add_rule</a> call, <code>Adding a rule requires the name of the rule.</code>: Any <a href="#section.queries_rules">rule</a> must have a unique name and the name must be added as value of the <code>name</code> attribute for the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.add_rule">/api/add_rule</a> call, <code>Providing which version to replace while adding a rule is not allowed.</code>: This api call lets you add new and only new rules. Hence, there can't be a <a href="#section.queries_rules">version to replace</a> of this rule.</li>
<li>For the <a href="#section.add_rule">/api/add_rule</a> call, <code>Providing a version-id while adding a rule is not allowed.</code>: This api call lets you add new and only new rules. Thus, the <a href="#section.queries_rules">version</a> of the new rule will be determined by the server.</li>
<li>For the <a href="#section.add_rule">/api/add_rule</a> call, <code>No content between start and end of the root-tag.</code>: You are trying to add an empty rule. This doesn't make sense. If you don't intended to upload an empty rule, please check the above section <em>Your input formatted for XML parsing</em> to determine what has happened to your input.</li>
<li>For the <a href="#section.get_rule">/api/get_rule</a> call, <code>No content between start and end of the root tag allowed when getting a rule.</code>: You are trying to retrieve an existing rule. Thus, there is no use for any content inside the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.get_rule">/api/get_rule</a> call, <code>Retrieving a rule requires the name of the rule.</code>: Any <a href="#section.queries_rules">rule</a> must have a unique name and the name must be added as value of the <code>name</code> attribute for the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.get_rule">/api/get_rule</a> call, <code>Providing a version which to replace while getting a rule is not allowed.</code>: This api call lets you retrieve rules. Most probably, you wanted to select a certain version of a rule. You can do so by using the <em>version</em> attribute of the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.update_rule">/api/update_rule</a> call, <code>Updating a rule requires the name of the rule.</code>: Any <a href="#section.queries_rules">rule</a> must have a unique name and the name must be added as value of the <code>name</code> attribute for the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.update_rule">/api/update_rule</a> call, <code>Updating a rule requires providing its last version-id.</code>: You are trying to replace an existing rule. To prevent <a href="#section.queries_rules">accidental edits</a>, you must specify the most current version of the existing rule as value to the <em>replace</em> attribute of the <a href="#section.osm_script">root element</a>.</li>
<li>For the <a href="#section.update_rule">/api/update_rule</a> call, <code>Providing an arbitrary version-id while updating a rule is not allowed.</code>: You are trying to replace an existing rule. You must specify the most recent version of the existing rule as value to the <em>replace</em> attribute of the <a href="#section.osm_script">root element</a>. But you can't specify the version id of the new version of the <a href="#section.queries_rules">rule</a>; the server itself selects to version id of the new version.</li>
</ul>

<p>
The only existing remark so far is:
</p>
<ul>
<li><code>Timeout is set to </code>timeout<code>, element_limit is </code>count: This repeats the value for the <a href="#section.quotas">amount of time</a> after which a query will be canceled and the <a href="#section.quotas">upper bound of element equivalents</a> beyond which the query will be canceled due to too much ressource comsuption. If one of the two is zero, the respective ressource is unlimited. You can specify these values with attributes of the <a href="#section.osm_script">root element</a>.</li>
</ul>

<p>
The section <strong>Flow Forecast</strong> contains the <a href="#section.flow_forecast">Flow Forecast</a> analysis. This analysis will be displayed as follows: Each statement is printed in the order of the <a href="#section.control_flow">control flow</a>. After each statement, in a section <em>Forecast</em>, the <a href="#section.flow_forecast">estimated time</a> elapsed at this point is displayed. Also for each existing <a href="#section.data_structures">set</a> at this point, <a href="#section.data_structures">its name</a> and the <a href="#section.flow_forecast">estimated number</a> of <a href="#section.data_structures">nodes, ways, relations and areas</a> contained in the set are printed. If you see the error message <code>Time exceeds limit of 180 seconds.</code>, your query is estimated to exceed the <a href="#section.quotas">default timeout</a> of 180 seconds and you need to <a href="#section.osm_script">manually set a timeout</a>. If you see the error message <code>Number of elements exceeds limit of 10,000,000 elements.</code>, your query is estimated to exceed the <a href="#section.quotas">amount of element equivalents limit</a>. Again, you need to <a href="#section.osm_script">manually set a limit for the amount of element equivalents</a>.
</p>

</body>
</html>
