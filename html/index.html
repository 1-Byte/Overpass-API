<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" lang="en"></meta>
  <title>OSM Server Side Script</title>
</head>
<body>

<h1>OSM Server Side Script</h1>

<!--
offene Probleme:
- gzip-Komprimierung
- area-query
- recurse: area-node
- Durchsetzung der Constraints
//-->

<p>
<a href="#chapter.introduction">Introduction</a> -
<a href="#chapter.use_cases">Use Cases</a> -
<a href="#chapter.interface_calls">Interface Calls</a> -
<a href="#chapter.statements">Statements</a> -
<a href="#chapter.concepts">Concepts</a> -
<a href="#chapter.input_formats">Input Formats</a> -
<a href="#chapter.output_formats">Output Formats</a>
</p>

<div>
<h2>Table of Contents</h2>
</div>

<p>
<a href="#chapter.introduction">Introduction</a><br/>
<a href="#chapter.use_cases">Use Cases</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.reverse_gazetteer">To which country belongs this location?</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.download_area">Download an entire city</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.debug_area">Why doesn't my city appear?</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.rule_example">Declare a new type of area</a><br/>
<a href="#chapter.interface_calls">Interface Calls</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.interpreter">/api/interpreter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.get_rule">/api/get_rule</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.add_rule">/api/add_rule</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.update_rule">/api/update_rule</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.status">/api/status</a><br/>
<a href="#chapter.statements">Statements</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.area_query">area-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.conflict">conflict</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.coord_query">coord-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.detect_odd_nodes">detect-odd-nodes</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.foreach">foreach</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.id_query">id-query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.item">item</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.make_area">make-area</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.osm_script">osm-script</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.print">print</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.query">query</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.recurse">recurse</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.report">report</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.union">union</a><br/>
<a href="#chapter.concepts">Concepts</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.data_structures">Data structures</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.scripts_rules">Scripts and Rules</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.control_flow">Control Flow</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.variables">Variables</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.other_sets">Other Sets in Scripts</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.flow_forecast">Flow Forecast</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.quotas">Limits and Quotas</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.database_layout">Database Layout</a><br/>
<a href="#chapter.input_formats">Input Formats</a><br/>
<a href="#chapter.output_formats">Output Formats</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.payload">Payload</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.status_remarks">Status Remarks</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.hypertext_reports">Hypertext Reports</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section.static_feedback">Static Error Feedback</a><br/>
</p>

<div>
<a id="chapter.introduction"/>
<h2>Introduction</h2>
</div>

<p>
</p>

<div>
<a id="chapter.use_cases"/>
<h2>Use Cases</h2>
</div>

<p>
<a href="#section.reverse_gazetteer">To which country belongs this location?</a><br/>
<a href="#section.download_area">Download an entire city</a><br/>
<a href="#section.debug_area">Why doesn't my city appear?</a><br/>
<a href="#section.rule_example">Declare a new type of area</a><br/>
</p>

<p>The following examples are some sample use cases to give you an idea
what you can do with the system. Of course, there are many more useful
use cases, and you are kindly invited to add other use cases in the wiki.</p>

<div>
<a id="section.reverse_gazetteer"/>
<h3>To which country belongs this location?</h3>
</div>

<p>
To determine in which areas a location specified by latitude and longitude lies, just change the latitude and longitude in the following script to appriate values: If your browser asks you what to do, just open the file with a text editor.<br/>
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="3" cols="80">&lt;coord-query lat="51.25" lon="7.15"/&gt;
&lt;print mode="body"/&gt;
</textarea>
  <input type="submit" value="Explore"/>
</form><br/>
Of course, you can send this script also via any other <a href="#chapter.input_formats">way of submitting input</a> to <a href="#section.interpreter">/api/interpreter</a>. You will recieve a gzip-compressed XML-file in an <a href="#chapter.output_formats">adapted OSM format</a> that <a href="#section.payload">contains the areas</a> the location lies in.
</p>

<p>
The first command, <a href="#section.coord_query">&lt;coord-query lat="51.25" lon="7.15"/&gt;</a>, searches the database for every area that covers the location defined by the latitude and longitude values. Then it stores the result into the <a href="#section.variables">default set</a>. Afterwards, the second command <a href="#section.print">&lt;print mode="body"/&gt;</a> prints the content of the default set. The mode="body" indicates there that it shall print the <a href="#section.data_structures">id and members</a> of the area as well as is <a href="#section.data_structures">tags</a>.<br/>
</p>

<div>
<a id="section.download_area"/>
<h3>Download an entire city</h3>
</div>

<p>
This is in general a two-step process. For the first step, determine the id of the area to download, e.g. from the result of a <a href="#section.coord_query">coord-query</a> like in the <a href="#section.reverse_gazetteer">above example</a>. Another way to determine the id is to take advantage of <a href="#section.data_structures">the way the areas obtain their id</a>:
<ul>
<li>An area based on a node has the same id as the node.</li>
<li>An area based on a way has the the id of the way plus 2,400,000,000.</li>
<li>An area based on a relation has the id of the relation plus 3,600,000,000.</li>
</ul>
For example, the area representing the German city "Wuppertal" has id 3,600,062,478 because its pivot element is the relation 62,478 describing the borders of Wuppertal. In particular this means that area ids are as stable as the ids in the OSM database. If you don't know the id of the OSM entity in question, then can simply <a href="#section.query">query</a> it.
</p>

<p>
The second step is the script to actually download the area: This script will take 15-30 seconds before it gives a response depending on server load.<br/>
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="8" cols="80">&lt;union&gt;
  &lt;area-query ref="3600062478"/&gt;
  &lt;recurse type="node-relation" into="rels"/&gt;
  &lt;recurse type="node-way"/&gt;
  &lt;recurse type="way-relation"/&gt;
&lt;/union&gt;
&lt;print mode="body"/&gt;
</textarea>
  <input type="submit" value="Download"/>
</form><br/>
Again, you can send this script also via any other <a href="#chapter.input_formats">way of submitting input</a> to <a href="#section.interpreter">/api/interpreter</a>. You will recieve a gzip-compressed XML-file in an <a href="#chapter.output_formats">adapted OSM format</a> that <a href="#section.payload">contains</a> all nodes that lie in this area (including all the nodes on the boundary), all ways that are referred from such a node and all relations that are referred by such a way or such a node.
</p>

<p>
If you prefer to receive additionally all nodes any way refers to, you can change the script to: This script also will take some time depending on server load before it gives a response.<br/>
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="16" cols="80">&lt;osm-script timeout="180"&gt;

&lt;union&gt;
  &lt;area-query ref="3600062478"/&gt;
  &lt;recurse type="node-relation" into="rels"/&gt;
  &lt;recurse type="node-way"/&gt;
  &lt;recurse type="way-relation"/&gt;
&lt;/union&gt;
&lt;union&gt;
  &lt;item/&gt;
  &lt;recurse type="way-node"/&gt;
&lt;/union&gt;
&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
  <input type="submit" value="Download"/>
</form><br/>
</p>

<p>
We briefly explain both scripts and start with the first one: The statement <a href="#section.union">&lt;union&gt;</a> <a href="#section.other_sets">collects</a> the output of the enclosed statements in line 2 to 6. The block starts with the query <a href="#section.area_query">&lt;area-query ref="3600062478"/&gt;</a>. This statement returns all the nodes that lie inside or on the border of the area with id given by the parameter ref and stores them in into the <a href="#section.variables">default set</a>. In the third line, <a href="#section.recurse">&lt;recurse type="node-relation" into="rels"/&gt;</a> returns all relations that have as member a node from the input, in this case the <a href="#section.variables">default set</a>, into the set "rels". As this happens within an <a href="#section.union">union</a>-block, the new content of the set "rels" is added to the result of the <a href="#section.union">union</a>-block as a whole. In the next line, <a href="#section.recurse">&lt;recurse type="node-way"/&gt;</a> puts into the <a href="#section.variables">default set</a> the ways that refer to at least one node from the <a href="#section.variables">default set</a>. In particular, the default set now contains only ways, the <a href="#section.union">union</a>-block has collected so far all nodes and ways and some relations. In the last line of the block, <a href="#section.recurse">&lt;recurse type="way-relation"/&gt;</a> puts into the <a href="#section.variables">default set</a> all relations that refer to at least one way from the <a href="#section.variables">default set</a> beforehand. The <a href="#section.union">union</a>-block again collects these relations. Now the <a href="#section.union">union</a>-block contains altogether the nodes within the area and the ways and relations that refer to such a node or way. As there is no output parameter given, this set is stored into the <a href="#section.variables">default set</a>. The statement after the block, <a href="#section.print">&lt;print mode="body"/&gt;</a> then prints the entire content of the <a href="#section.variables">default set</a> with all its details as specified by the value "body" of the parameter "mode".
</p>

<p>
The second script differs from the first one in two aspects: It exhibits the root element <a href="#section.osm_script">&lt;osm-script timeout="180"&gt;</a> to change a global setting from its default: Without explicit timeout, the server <a href="#section.flow_forecast">forecasts</a> the runtime of the script and refuses its execution if it could take too much ressources. With a manual <a href="#section.quotas">timeout</a>, the script will be accepted regardless of its predicted runtime, but it will be aborted if it exceeeds its timeout. The second difference is the second <a href="#section.union">union</a>-block: The first statement <a href="#section.item">&lt;item/&gt;</a> just makes the current <a href="#section.variables">default set</a> part of the result of the <a href="#section.union">union</a>-block. The second statement <a href="#section.recurse">&lt;recurse type="way-node"/&gt;</a> replaces the <a href="#section.variables">default set</a> with the set of all nodes that are referred by the ways in the <a href="#section.variables">default set</a> beforehand. This result is collected by the <a href="#section.union">union</a>-block. Thus, the result now conatins all nodes that are referred by a way appearing in the set.
</p>

<div>
<a id="section.debug_area"/>
<h3>Why doesn't my city appear?</h3>
</div>

<p>
You may get into the situation that you don't find an area where you expect one. In particular, a coord-query like the <a href="#section.reverse_gazetteer">first</a> use case doesn't contain the data of an area although there exists for example a relation to create it. In this case, you can query the <a href="#section.data_structures">conflicts</a> that prevented the respective area creation <a href="#section.scripts_rules">rule</a> to create an area from this. The following script will try to find conflicts related to the relation of the German city "Wuppertal": You should replace "Wuppertal, Stadt" by a suitable value for you relation.
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="5" cols="80">&lt;query type="relation"&gt;
  &lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;
&lt;/query&gt;
&lt;report/&gt;
</textarea>
  <input type="submit" value="Find Conflicts"/>
</form><br/>
The server will return a <a href="#section.hypertext_reports">human readable HTML document</a> that lists the conflicts related to this relation; these are generated by <a href="#section.rule_example">user editable rules</a> and should be self-explanatory. The result can be empty (and probably will be empty for Wuppertal because the respective area has successfully been created), but we simply can't leave an area in permanently broken state to show how the conflict feedback system works.
</p>

<p>
If you get an empty result from the first query, check whether there exists a relation at all:
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="5" cols="80">&lt;query type="relation"&gt;
  &lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;
&lt;/query&gt;
&lt;print mode="body"/&gt;
</textarea>
  <input type="submit" value="Find Relations"/>
</form><br/>
This searches the data for all relations that match the given criteria, i.e. that have a tag with key "name" and value "Wuppertal".
</p>

<p>
If you already know the id of your relation, you can use instead the following to find conflicts:
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="3" cols="80">&lt;id-query type="relation" ref="62478"/&gt;
&lt;report/&gt;
</textarea>
  <input type="submit" value="Find Conflicts"/>
</form><br/>
</p>

<p>
We give a short overview of the used statement: the query <a href="#section.query">&lt;query type="relation"&gt;&lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;&lt;/query&gt;</a> searches for relations (this is specified by the parameter type) that have a tag with key "name" and value "Wuppertal, Stadt" (this condition is specified by the tag <a href="#section.query">&lt;has-kv k="name" v="Wuppertal, Stadt"/&gt;</a>. A full explanation of the quite versatile syntax of the query statement can be found in <a href="#section.query">its documentation</a>. The <a href="#section.id_query">&lt;id-query type="relation" ref="62478"/&gt;</a> by contrast finds the single relation with id 62478 as specified by the parameter ref. Both store their result into the <a href="#section.variables">default set</a> because there is no other set specified. Then, the statement <a href="#section.report">&lt;report/&gt;</a> prints to the user all conflicts that are related to an item in its input, again the <a href="#section.variables">default set</a>. It doesn't change any values in the script. Alternatively, the <a href="#section.print">&lt;print mode="body"/&gt;</a> simply prints the entire content of the <a href="#section.variables">default set</a>.
</p>

<div>
<a id="section.rule_example"/>
<h3>Declare a new type of area</h3>
</div>

<p>
Not all relations that refer to ways give automatically rise to a relation. The server recognizes a certain relation (or any other designated set of ways) as an area if a <a href="#section.scripts_rules">rule</a> matches this relation or set of ways. The amazing thing is that you (or anybody else) can <a href="#section.add_rule">add</a> rules or <a href="#section.update_rule">change</a> the existing ones. Now assume that you want to designate all relations with a tag with key "foo" and value "bar" to represent areas.
</p>

<p>
You can <a href="#section.get_rule">retrieve</a> an existing rule to get a blueprint for our new rule. For example, the following query will return the rule that creates areas from administrative units:
<form action="api/get_rule" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="2" cols="80">&lt;osm-script name="Area::Create_from_admin_level"/&gt;
</textarea>
  <input type="submit" value="Retrieve rule"/>
</form><br/>
This will give you a result like the following:
<code><pre>
&lt;osm-script name="Area::Create_from_admin_level" version="1"&gt;

&lt;query type="relation"&gt;
  &lt;has-kv k="admin_level"/&gt;
  &lt;has-kv k="name"/&gt;
&lt;/query&gt;
&lt;foreach into="rel"&gt;
  &lt;union&gt;
    &lt;recurse type="relation-way" from="rel"/&gt;
    &lt;recurse type="way-node"/&gt;
  &lt;/union&gt;
  &lt;make-area pivot="rel" into="odd"/&gt;
  &lt;detect-odd-nodes into="odd"/&gt;
  &lt;foreach from="odd" into="i"&gt;
    &lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;
    &lt;conflict&gt;In &lt;item set="rel"/&gt;, the &lt;item set="i"/&gt; is contained in an odd number of segments.&lt;/conflict&gt;
  &lt;/foreach&gt;
&lt;/foreach&gt;

&lt;/osm-script&gt;
</pre></code>
</p>

<p>
We take the following modifications: In the first line, we replace the <a href="#section.osm_script">name</a> of the rule by a new, descriptive name because we are adding a new rule. We remove the <a href="#section.osm_script">version tag</a> because this will be chosen by the server. Then, we replace the two lines starting with <a href="#section.query">has-kv</a> by a single line that describes the designation for the relations in question. Then we post the new rule to <a href="#section.add_rule">add_rule</a>:
<form action="api/add_rule" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="21" cols="80">&lt;osm-script name="Example::Foo"&gt;

&lt;query type="relation"&gt;
  &lt;has-kv k="foo" v="bar"/&gt;
&lt;/query&gt;
&lt;foreach into="rel"&gt;
  &lt;union&gt;
    &lt;recurse type="relation-way" from="rel"/&gt;
    &lt;recurse type="way-node"/&gt;
  &lt;/union&gt;
  &lt;make-area pivot="rel" into="odd"/&gt;
  &lt;detect-odd-nodes into="odd"/&gt;
  &lt;foreach from="odd" into="i"&gt;
    &lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;
    &lt;conflict&gt;In &lt;item set="rel"/&gt;, the &lt;item set="i"/&gt; is contained in an odd number of segments.&lt;/conflict&gt;
  &lt;/foreach&gt;
&lt;/foreach&gt;

&lt;/osm-script&gt;
</textarea>
  <input type="submit" value="Add sample rule"/>
</form><br/>
You should recieve a message that the rule has successfully been added along with its new version number. If you recieve a the error that a rule with this name already exists, you have probably not changed the name in the above rule (and another guy already has left this example in the rule base).
</p>

<p>
To avoid cluttering the server, please complete this tutorial with removing your rule. Just call <a href="#section.update_rule">update_rule</a> with the empty rule and the parameter <a href="#section.osm_script">replace</a> set to the version number just recieved:
<form action="api/update_rule" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="2" cols="80">&lt;osm-script name="Example::Foo" replace="0"/&gt;
</textarea>
  <input type="submit" value="Delete rule"/>
</form><br/>
You should recieve a message that the rule has successfully been updated. If you recieve the error that you should provide the last version-id, then call again <a href="#section.get_rule">get_rule</a> on you rule:
<form action="api/get_rule" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="2" cols="80">&lt;osm-script name="Example::Foo"/&gt;
</textarea>
  <input type="submit" value="Retrieve rule"/>
</form><br/>
The result contains the correct version number.
</p>

<p>
We conclude by explaining the statements in the rule "Area::Create_from_admin_level": The first line <a href="#section.osm_script">&lt;osm-script name="Area::Create_from_admin_level" version="1"&gt;</a> is an explicit statement of the <a href="#section.osm_script">root element</a> because a rule <a href="#section.scripts_rules">needs always</a> a name and the name is provided as parameter of the root element. The <a href="#section.osm_script">version tag</a> is added by the server to indicate which version of the rule it has returned - in our example the most recent version which is by incidence 1.
</p>

<p>
The first executable statement in the rule is the query-block <a href="#section.query">&lt;query type="relation"&gt;&lt;has-kv k="admin_level"/&gt;&lt;has-kv k="name"/&gt;&lt;/query&gt;</a>. This query-block searches for relations as specified by the parameter "type". It returns only relations that have a tag with key "admin_level" and a tag with key "name". For both tags, any values match the search criteria as there are no values specified in the <a href="#section.query">has-kv</a> tags. The results of the query are stored into the <a href="#section.variables">default set</a>. A detailed description of the query syntax can be found in <a href="#section.query">its documentation</a>.
</p>

<p>
The <a href="#section.foreach">&lt;foreach into="rel"&gt;</a> statement regulates the <a href="#section.control_flow">control flow</a>: The body is executed once for each element in the input set. As there is no input set specified, the input is taken from the <a href="#section.variables">default set</a>. The output set "rel" contains during each loop solely the respective element from the input set.
</p>

<p>
The <a href="#section.foreach">foreach</a>-body starts with an <a href="#section.union">union</a>-block, containing the two statements <a href="#section.recurse">&lt;recurse type="relation-way" from="rel"/&gt;</a> and <a href="#section.recurse">&lt;recurse type="way-node"/&gt;</a>. The first one sets the <a href="#section.variables">default set</a> to the set of all ways that are members of the relation in the input set "rel". The second sets the <a href="#section.variables">default set</a> to the set of all nodes that are referred by ways from the <a href="#section.variables">default set</a>. Because of the <a href="#section.union">union</a>-block wrapped around, the <a href="#section.variables">default set</a> contains afterwards the ways that are members of the relation and their associated nodes.
</p>

<p>
The statement <a href="#section.make_area">&lt;make-area pivot="rel" into="odd"/&gt;</a> now creates the area: It takes input from two different sets. The first one not specified, thus being the <a href="#section.variables">default set</a>, contains the ways and nodes that decribe the spatial extent of the area; it contains any point that is separated from the south pole by an odd number of way segments. The second input set is specified by the <a href="#section.make_area">pivot</a> parameter. It should contain exactly one element, and the set "rel", set by <a href="#section.foreach">foreach</a>, does so. The area's <a href="#section.data_structures">id and tags</a> are derived from this element. The output of <a href="#section.make_area">make-area</a> is the created area if any. It is simultanenously written to the output set as well as the <a href="#section.data_structures">database</a>. The set is in our case redirected to the set "odd" as we don't need the area anymore.
</p>

<p>
The <a href="#section.detect_odd_nodes">&lt;detect-odd-nodes into="odd"/&gt;</a> statement detects nodes that appear an odd times as starting or end points of a way. These nodes are exactly the nodes that prevent <a href="#section.make_area">make-area</a> from making an area. The <a href="#section.detect_odd_nodes">detect-odd-nodes</a> statement takes its input from the <a href="#section.variables">default set</a> because there is no other set specified. The default set still contains the ways and nodes to produce an area from. The odd nodes are returned into the specified output set "odd".
</p>

<p>
The <a href="#section.foreach">&lt;foreach from="odd" into="i"&gt;</a> statement <a href="#section.control_flow">loops</a> over these nodes, which are stored in the input set "odd". Each node is during one loop available as content of the set "i". In the loop, the line <a href="#section.union">&lt;union&gt;&lt;item set="i"/&gt;&lt;item set="rel"/&gt;&lt;/union&gt;</a> sets the <a href="#section.variables">default set</a> to the node of the inner loop and the relation from the outer loop: The <a href="#section.item">&lt;item set="i"/&gt;</a> statement returns the content of the set "i" as output, hence the node of the current inner loop. The <a href="#section.item">&lt;item set="rel"/&gt;</a> returns the set "rel" that contains the relation of the current outer loop.
</p>

<p>
Finally, the line <code><a href="#section.conflict">&lt;conflict&gt;</a>In <a href="#section.conflict">&lt;item set="rel"/&gt;</a>, the <a href="#section.conflict">&lt;item set="i"/&gt;</a> is contained in an odd number of segments.<a href="#section.conflict">&lt;/conflict&gt;</a></code> writes the conflict message into the database for the elements of the current inner and current outer loop. It obtains these elements from its input set, the <a href="#section.variables">default set</a>. In the conflict message, the subtags <a href="#section.conflict">&lt;item set="rel"/&gt;</a> and <a href="#section.conflict">&lt;item set="i"/&gt;</a> are replaced by their contents. The <a href="#section.conflict">conflict</a> statement does not return anything. Then the script continues with another inner loop or outer loop respectively.
</p>


<div>
<a id="chapter.interface_calls"/>
<h2>Interface Calls</h2>
</div>

<p>
<a href="#section.interpreter">/api/interpreter</a><br/>
<a href="#section.get_rule">/api/get_rule</a><br/>
<a href="#section.add_rule">/api/add_rule</a><br/>
<a href="#section.update_rule">/api/update_rule</a><br/>
<a href="#section.status">/api/status</a><br/>
</p>

<div>
<a id="section.interpreter"/>
<h3>/api/interpreter</h3>
</div>

<div>
<a id="section.get_rule"/>
<h3>/api/get_rule</h3>
</div>

<div>
<a id="section.add_rule"/>
<h3>/api/add_rule</h3>
</div>

<div>
<a id="section.update_rule"/>
<h3>/api/update_rule</h3>
</div>

<div>
<a id="section.status"/>
<h3>/api/status</h3>
</div>

<div>
<a id="chapter.statements"/>
<h2>Statements</h2>
</div>

<p>
<a href="#section.area_query">area-query</a><br/>
<a href="#section.conflict">conflict</a><br/>
<a href="#section.coord_query">coord-query</a><br/>
<a href="#section.detect_odd_nodes">detect-odd-nodes</a><br/>
<a href="#section.foreach">foreach</a><br/>
<a href="#section.id_query">id-query</a><br/>
<a href="#section.item">item</a><br/>
<a href="#section.make_area">make-area</a><br/>
<a href="#section.osm_script">osm-script</a><br/>
<a href="#section.print">print</a><br/>
<a href="#section.query">query</a><br/>
<a href="#section.recurse">recurse</a><br/>
<a href="#section.report">report</a><br/>
<a href="#section.union">union</a><br/>
</p>

<div>
<a id="section.area_query"/>
<h3>area-query</h3>
</div>

<div>
<a id="subsection.area_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>ref</strong>: the <a href="#section.data_structures">id of the area</a> to consider.</li>
</ul>

<div>
<a id="subsection.area_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.area_query.description"/>
<h4>Description</h4>
</div>

<p>
The area-query returns all nodes that have coordinates within the provided area, identified by <a href="#section.variables">its id</a>. A node is considered to be <a href="#section.variables">within</a> an area if it is in the interior or on the boundary of an area. The nodes are stored in the set specified by "into".
</p>

<div>
<a id="subsection.area_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.area_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.conflict"/>
<h3>conflict</h3>
</div>

<div>
<a id="subsection.conflict.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.conflict.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.conflict.description"/>
<h4>Description</h4>
</div>

<p>
The conflict statement tags permanently (until the next rule application) one or more objects in the database as being invoked into a conflict. It is intended to be used in rules to mark objects that should be reviewed by a human in the context of the rule. The statement composes from the text and the <a href="#section.item">item</a> subelements within the element a message that should describe the conflict. Every object contained int the input set as specified by the parameter from is then tagged with this message. The messages for a given object can at any instant afterwards be query with the <a href="#section.report">report</a> statement.
</p>

<div>
<a id="subsection.conflict.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.conflict.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.coord_query"/>
<h3>coord-query</h3>
</div>

<div>
<a id="subsection.coord_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>lat</strong>: a valid latitude on earth, i.e. a floating point number between -90.0 and 90.0. It is evaluted with a precision of 10<sup>-7</sup> degrees.</li>
<li><strong>lon</strong>: a valid longitude on earth, i.e. a floating point number between -180.0 and 180.0. It is evaluted with a precision of 10<sup>-7</sup> degrees.</li>
</ul>

<div>
<a id="subsection.coord_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.coord_query.description"/>
<h4>Description</h4>
</div>

<p>
This statement returns as the set specifed by "into" all areas that cover the location on earth specified by the coordinates lat and lon. An area is also returned if the given location lies on its boundary.
</p>

<div>
<a id="subsection.coord_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.coord_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.detect_odd_nodes"/>
<h3>detect-odd-nodes</h3>
</div>

<div>
<a id="subsection.detect_odd_nodes.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.detect_odd_nodes.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.detect_odd_nodes.description"/>
<h4>Description</h4>
</div>

<p>
This statements detects in a set of ways all nodes that appear odd times as a endpoint. For a couple of tasks like the <a href="#section.area_query">derivation of an area</a> from a set of ways, an essential precondition is that the ways fit together. Fitting together means in this context that there is no junction of an odd number of segments at any node, because it that case, it is not well-defined which points of that polygon are inner and which not. Inner nodes of a way are always adjacent to two segments within that way so that they can be ignored. The statement takes the ways from the set specified by the argument "from" and puts the detected nodes into the argument "into".
</p>

<div>
<a id="subsection.detect_odd_nodes.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.detect_odd_nodes.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.foreach"/>
<h3>foreach</h3>
</div>

<div>
<a id="subsection.foreach.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.foreach.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.foreach.description"/>
<h4>Description</h4>
</div>

<p>
The foreach statement executes the sequence of its inner elements once for each element in the set specified by the argument "from". In particular, the set specified by the argument "from" will be stored on an internal stack. Then, for each element in the set specified by the argument "from", the following things will happen: first, the set specified by the argument "into" will be set to contain solely the element the loop is dedicated to. Then, the statements in the loop are executed. Finally, the server continues with the next loop. The order of the indivdual loops is unspecified, only the order within a loop adheres to the order in the source code.
</p>

<div>
<a id="subsection.foreach.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.foreach.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.id_query"/>
<h3>id-query</h3>
</div>

<div>
<a id="subsection.id_query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation", "way" or "node".</li>
<li><strong>ref</strong>: the <a href="#section.data_structures">id</a> of the object to consider.</li>
</ul>

<div>
<a id="subsection.id_query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.id_query.description"/>
<h4>Description</h4>
</div>

<p>
This statement queries the database for the single object of the specified type and with the specified id. It returns as the set specified by the argument "into" the set consisting of this object or an empty set if the object doesnt exist.
</p>

<div>
<a id="subsection.id_query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.id_query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.item"/>
<h3>item</h3>
</div>

<div>
<a id="subsection.item.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.item.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>set</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.item.description"/>
<h4>Description</h4>
</div>

<p>
The item statement declares its argument as output. This is used within the <a href="#section.union">union</a> statement and the <a href="#section.conflict">conflict</a> statement to refer to an existing set.
</p>

<div>
<a id="subsection.item.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.item.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.make_area"/>
<h3>make-area</h3>
</div>

<div>
<a id="subsection.make_area.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>pivot</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.make_area.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.make_area.description"/>
<h4>Description</h4>
</div>

<p>
This statement creates an area from a multipolygon, writes this area into the database and returns this area as output. From a general mathematical point of view, one can define an area from its boundary as follows: you fix the boundary and a single point that is outside the area. Then a point is outside if and only if any curve to the outside point crosses an even number of segments. We use this definition and take as the outside point always the south pole and the set of ways in the input set (specified by the argument "from") as boundary. The make-area statement now requires that the input set contains all nodes that are referred by at least one way in the set. Furthermore, it requires that the ways fit together. This means that any node is referred by an even number of segments. Otherwise there would be a boundary with interior or the exterior on both sides. The area then consists of all points such that you have to cross an odd number of segments to reach the south pole. The area is tagged with all tags from the pivot element and obtains its <a href="#section.data_structures">id</a> as follows:
<ul>
<li>An area based on a node has the same id as the node.</li>
<li>An area based on a way has the the id of the way plus 2,400,000,000.</li>
<li>An area based on a relation has the id of the relation plus 3,600,000,000.</li>
</ul>
The statement finally returns as the output set specified by "into" the set consisting of the newly created area. If a precondition fails, it writes nothing to the database, produces a <a href="#section.status_remarks">status remark</a> and returns the empty set.
</p>

<div>
<a id="subsection.make_area.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.make_area.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.osm_script"/>
<h3>osm-script</h3>
</div>

<div>
<a id="subsection.osm_script.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.osm_script.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>timeout</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): a nonnegative integer describing an amount of seconds.</li>
<li><strong>element-limit</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): a nonnegative integer describing a limit for element usage.</li>
<li><strong>debug</strong> (only with <a href="#section.interpreter">/api/interpreter</a>): one of the values "quiet", "errors", "verbose" or "static". It defaults to "errors".</li>
<li><strong>name</strong> (only with <a href="#section.get_rule">/api/get_rule</a>, <a href="#section.add_rule">/api/add_rule</a> or <a href="#section.update_rule">/api/update_rule</a>): an arbitrary string describing an identifier for a rule.</li>
<li><strong>version</strong> (only with <a href="#section.get_rule">/api/get_rule</a>): the version id of the rule.</li>
<li><strong>replace</strong> (only with <a href="#section.update_rule">/api/update_rule</a>): the version id of the rule to replace.</li>
</ul>

<div>
<a id="subsection.osm_script.description"/>
<h4>Description</h4>
</div>

<p>
This is the root element of all scripts. You <a href="#chapter.input_formats">may omit</a> this element if you don't need to provide an explicit argument. Which arguments are useful depends on whether you write a <a href="#section.scripts_rules">script</a> or a <a href="#section.scripts_rules">rule</a>.
</p>

<p>
The parameters "timeout" and "element-limit" are used to <a href="#section.quotas">assert</a> that a script has a reasonable ressource consumption. It is only necessary if the <a href="#section.flow_forecast">flow forecast</a> can't predict a modest ressource consumption directly. If the script exceeds its asserted limits, it will be aborted. The parameter "debug" controls how much meta information is included: if it is set to "quiet", no meta information will be added. If it is set to "errors", it displays only errors. If it is set to "verbose", it shows all the messages explained in <a href="#section.status_remarks">Status Remarks</a>. If it is set to "static", it won't run the script but display the <a href="#section.flow_forecast">flow forecast</a> for this script.
</p>

<p>
For a rule, the parameter "name" provides to name of the rule. It is used to <a href="#section.add_rule">add</a> a rule or to <a href="#section.update_rule">update</a> an existing one, as well as to <a href="#section.get_rule">query</a> a rule. The parameter "version" tells you which <a href="#section.scripts_rules">version</a> a given rule has. As a safety measure, if you intent want to update a rule, you need to specify by the "replace" parameter the version of the rule to replace.
</p>

<div>
<a id="subsection.osm_script.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.osm_script.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.print"/>
<h3>print</h3>
</div>

<div>
<a id="subsection.print.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.print.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>mode</strong>: one of the values "ids_only", "skeleton" or "body". If it is omitted, it defaults to "skeleton".</li>
</ul>

<div>
<a id="subsection.print.description"/>
<h4>Description</h4>
</div>

<p>
The statement prints the content of its input set specified by "from" into the response document. The output contains only the objects' ids if mode is set to "ids_only". It contains the ids, the coordinates of nodes and the members of ways and relations if mode is set to "skeleton". It contains all the information about the objects including their tags if the mode is set to "body".
</p>

<div>
<a id="subsection.print.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.print.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.query"/>
<h3>query</h3>
</div>

<div>
<a id="subsection.query.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation", "way" or "node".</li>
</ul>

<div>
<a id="subsection.query.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.query.description"/>
<h4>Description</h4>
</div>

<p>
The query statement finds all objects of the specified type that have all the provided tags. The search criteria is formulated with one or more subelements of the form <code>&lt;has-kv k="foo" v="bar"/&gt;</code> or <code>&lt;has-kv k="foo"/&gt;</code>. The strings "foo" and "bar" should be replaced by the respective tags to search for. The former element restricts the result to objects that have a tag with the given key and the given value, the latter element restricts the result to objects that have a tag with the given key and arbitrary value.
</p>

<div>
<a id="subsection.query.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.query.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.recurse"/>
<h3>recurse</h3>
</div>

<div>
<a id="subsection.recurse.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<ul>
<li><strong>type</strong>: one of the values "relation-relation", "relation-backwards", "relation-way", "relation-node", "way-node", "way-relation", "node-relation" or "node-way"</li>
</ul>

<div>
<a id="subsection.recurse.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.recurse.description"/>
<h4>Description</h4>
</div>

<p>
The statement deduces from all nodes, ways or relations in the input set the referred nodes, ways or relations and returns them into the output set. Depending on the value of "type", the statement behaves as follows:
</p>
<ul>
<li><strong>relation-relation</strong>: The statement returns all relations that are members of at least one relation from the input set.</li>
<li><strong>relation-way</strong>: The statement returns all ways that are members of at least one relation from the input set.</li>
<li><strong>relation-node</strong>: The statement returns all nodes that are members of at least one relation from the input set.</li>
<li><strong>relation-backwards</strong>: The statement returns every relation that refers to at least one relation from the input set as a member.</li>
<li><strong>way-node</strong>: The statement returns all nodes that are members of at least one way from the input set.</li>
<li><strong>way-relation</strong>: The statement returns every relation that refers to at least one way from the input set as a member.</li>
<li><strong>node-relation</strong>: The statement returns every relation that refers to at least one node from the input set as a member.</li>
<li><strong>node-way</strong>: The statement returns every way that refers to at least one node from the input set as a member.</li>
</ul>

<div>
<a id="subsection.recurse.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.recurse.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.report"/>
<h3>report</h3>
</div>

<div>
<a id="subsection.report.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.report.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>from</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.report.description"/>
<h4>Description</h4>
</div>

<p>
The statement queries the database for conflicts recorded by the <a href="#section.conflict">conflict</a> statement. It prints all conflicts that are related to any object in the set specified by "from" into the response document. If there is no <a href="#section.print">print</a> statement in the script, the output is formatted as <a href="#section.hypertext_reports">hypertext report</a>.
</p>

<div>
<a id="subsection.report.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.report.examples"/>
<h4>Examples</h4>
</div>

<div>
<a id="section.union"/>
<h3>union</h3>
</div>

<div>
<a id="subsection.union.mandatory"/>
<h4>Mandatory parameters</h4>
</div>

<p>
none
</p>

<div>
<a id="subsection.union.optional"/>
<h4>Optional parameters</h4>
</div>

<ul>
<li><strong>into</strong>: the name of a set. If it is omitted, it defaults to the <a href="#section.variables">default set</a> "_".</li>
</ul>

<div>
<a id="subsection.union.description"/>
<h4>Description</h4>
</div>

<p>
The union statement collects the output sets of its subelements and returns them as the set specified by "into". For each statement, the output set is the set specified by the parameter "into" or the empty set if the statement has no parameter "into". The only exception from this rule is the <a href="#section.item">item</a> statement. This statement designates its output set by its sole argument "set".
</p>

<div>
<a id="subsection.union.properties"/>
<h4>Properties</h4>
</div>

<div>
<a id="subsection.union.examples"/>
<h4>Examples</h4>
</div>


<div>
<a id="chapter.concepts"/>
<h2>Concepts</h2>
</div>

<p>
<a href="#section.data_structures">Data structures</a><br/>
<a href="#section.scripts_rules">Scripts and Rules</a><br/>
<a href="#section.control_flow">Control Flow</a><br/>
<a href="#section.variables">Variables</a><br/>
<a href="#section.other_sets">Other Sets in Scripts</a><br/>
<a href="#section.flow_forecast">Flow Forecast</a><br/>
<a href="#section.quotas">Limits and Quotas</a><br/>
<a href="#section.database_layout">Database Layout</a><br/>
</p>

<div>
<a id="section.data_structures"/>
<h3>Data structures</h3>
</div>

<div>
<a id="section.scripts_rules"/>
<h3>Scripts and Rules</h3>
</div>

<div>
<a id="section.control_flow"/>
<h3>Control Flow</h3>
</div>

<div>
<a id="section.variables"/>
<h3>Variables</h3>
</div>

<div>
<a id="section.other_sets"/>
<h3>Other Sets in Scripts</h3>
</div>

<div>
<a id="section.flow_forecast"/>
<h3>Flow Forecast</h3>
</div>

<div>
<a id="section.quotas"/>
<h3>Limits and Quotas</h3>
</div>

<div>
<a id="section.database_layout"/>
<h3>Database Layout</h3>
</div>

<div>
<a id="chapter.input_formats"/>
<h2>Input Formats</h2>
</div>

<p>
Basically, the input is a complete XML document with root element <a href="#section.osm_script">osm-script</a>. There is no formal DTD but the allowed elements are exactly the statements as explained in the <a href="#chapter.statements">statement</a> chapter of this manual. This includes for each statement its allowed subelements, called substatements in <a href="#chapter.statements">this</a> context, and tags, called parameters in <a href="#chapter.statements">this</a> context. The XML syntax is modified in two ways: To make input as brief as possible, you can omit some parts of the XML code. To make input as flexible as possible, you can encode the input in different manners. In the following sections, we explain both modifications in detail with the simple script <code>&lt;print mode="body"/&gt;</code>
</p>

<p>
You can always omit the file type declaration. For example, the input
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="7" cols="80">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;osm-script&gt;

&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
  <input type="submit" value="Return nothing"/>
</form><br/>
and the input
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="6" cols="80">&lt;osm-script&gt;

&lt;print mode="body"/&gt;

&lt;/osm-script&gt;
</textarea>
  <input type="submit" value="Return nothing"/>
</form><br/>
are from the server's point of view equal. If you don't need to specify any parameters in the <a href="#section.osm_script">root element</a>, you can even omit the root element itself. So, even the input
<form action="api/interpreter" method="post" accept-charset="UTF-8">
  <textarea name="data" rows="2" cols="80">&lt;print mode="body"/&gt;
</textarea>
  <input type="submit" value="Return nothing"/>
</form><br/>
is for the server the same input as the above examples.
</p>

<p>
We explain the different possible encodings. To make it possible to submit data via HTML forms, you can either send your data verbatim or prefix it by "<code>data=</code>" and escape all special characters to a sequence of a percent sign, followed by the value of the respective byte as hexdecimal number. Multi-byte characters should be expanded in a individual sequence for each byte. For example, the inputs
<pre><code>
&lt;print mode="body"/&gt;
</code></pre>
and
<pre><code>
data=%3Cprint%20mode=%22body%22/%3E
</code></pre>
and
<pre><code>
data=%3Cprint%20mode=%22body%22/%3E&amp;this_garbage_will_be_ignored
</code></pre>
and
<pre><code>
foo=bar&amp;data=%3Cprint%20mode=%22body%22/%3E&amp;this_garbage_will_be_ignored
</code></pre>
are equal. The transformation from the former to the latter is normally done by your browser or client program automatically or even from the users point of view unintentionally. So if you get a <a href="#section.static_feedback">encoding error</a>, try prefixing your script by "data=". The server tries to interpret your input verbatim if the first non-whitespace character found is a verbatim "&lt;", in all other cases it searches for a "data=" substring, takes and decodes the input from that position until the next verbatim "&amp;".
</p>

<p>
We explain the different possible encodings. You can send your data by a HTTP GET request as well as by a HTTP POST request, with precedence for the GET payload if you send both simultaneously. To continue the above example, the URL<br/>
<pre>  <a href="http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E">http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E</a></pre>
is equal to any of the above queries.
</p>

<p>
If you want to use the famous program wget to retrieve the data from the server, you can use any of the sample command lines
<pre><code>
wget -O - http://78.46.81.38/api/interpreter?data=%3Cprint%20mode=%22body%22/%3E | gunzip
</code></pre>
or
<pre><code>
wget -O - --post-data="data=%3Cprint%20mode=%22body%22/%3E" http://78.46.81.38/api/interpreter | gunzip
</code></pre>
or
<pre><code>
wget -O - --post-data="&lt;print mode=\"body\"/&gt;" http://78.46.81.38/api/interpreter | gunzip
</code></pre>
Note that in the third variant the quotation marks are escaped in the usual shell style. The output is piped into gunzip to make it visible as uncompressed XML. A more appropriate way for longer script would be to save your script into a file, e.g. <code>foo.xml</code> and then use the command
<pre><code>
wget -O - --post-file=foo.xml http://78.46.81.38/api/interpreter | gunzip
</code></pre>
</p>

<div>
<a id="chapter.output_formats"/>
<h2>Output Formats</h2>
</div>

<p>
<a href="#section.payload">Payload</a><br/>
<a href="#section.status_remarks">Status Remarks</a><br/>
<a href="#section.hypertext_reports">Hypertext Reports</a><br/>
<a href="#section.static_feedback">Static Error Feedback</a><br/>
</p>

<div>
<a id="section.payload"/>
<h3>Payload</h3>
</div>

<div>
<a id="section.status_remarks"/>
<h3>Status Remarks</h3>
</div>

<div>
<a id="section.hypertext_reports"/>
<h3>Hypertext Reports</h3>
</div>

<div>
<a id="section.static_feedback"/>
<h3>Static Error Feedback</h3>
</div>

</body>
</html>
