<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" lang="en"></meta>
  <title>OSM Server Side Script</title>
</head>
<body>

<h1>Convert form</h1>

<form action="api/convert" method="get" accept-charset="UTF-8">
<p>
<textarea name="data" rows="25" cols="80"></textarea>
<input type="radio" name="target" value="xml">to pretty XML
<input type="radio" name="target" value="mapql">to pretty MapQL
<input type="radio" name="target" value="compact">to compact MapQL
<input type="radio" name="target" value="openlayers">to OpenLayers overlay
<input type="submit" value="Convert"/>
</p>
</form>

<h1>MapQL</h1>

<p>Please input a sequence of queries or actions. Queries extract data into a set, actions produce some output based on their input set.</p>

<p>A simple example is</p>
<pre>node[name=&quot;Gielgen&quot;]
{ out meta; }</pre>

<p>The action is <em>{ out meta; }</em>. The general form of an action is <em>.&lt;input variable&gt;{ out &lt;modifiers&gt;; }</em>. The input variable can be ommited; then it defaults to <em>_</em>. Allowed modifiers are</p>
<ul>
<li><em>ids</em>: Print only the id of each element.</li>
<li><em>skel</em>: Print ids, coordinates and memberships.</li>
<li><em>body</em>: Print the complete spatial data.</li>
<li><em>meta</em>: Print the complete spatial and meta data.</li>
<li><em>quirks</em>: Fake the meta data to cope with overzealous parsers. Not yet implemented.</li>
<li><em>qt</em>: Order by quadtile instead of id.</li>
<li><em>asc</em>: Order printed elements by id.</li>
</ul>
<p>The default options are <em>body</em> and <em>asc</em>.</p>

<p>The query consists of a type selector <em>node</em> and a clause <em>[name=&quot;Gielgen&quot;]</em> to select all elements that have a key &quot;name&quot; with value &quot;Gielgen&quot;. In general, a query consists of one of the type specifiers <em>node</em>, <em>way</em> or <em>relation</em> (abbreviated <em>rel</em>), an input variable if applicable, one or more clauses and always an output variable. If the output variable is omitted, it defaults to <em>_</em>. The result sets of the clauses are intersected to produce a result. If an input variable is present, the input set is addtionally intersected with the result.</p>

<p>The input variable is inserted before the first clause, the output variable is appended with an arrow: <em>&lt;type&gt;.&lt;input variable&gt;&lt;clauses&gt;->.&lt;output variable&gt;</em>.</p>

<p>The following clauses are possible:</p>
<ul>
<li><em>bbox</em>: written as <em>(</em>south<em>,</em>west<em>,</em>north<em>,</em>east<em>)</em>. An example is <pre>node[highway=bus_stop](50.6,6.8,50.9,7.2){out;}</pre>.</li>
<li><em>id</em>: written as <em>(</em>ref<em>)</em>, where <em>ref</em> is the id of the referred element. An example is <pre>rel(62478){out;}</pre></li>
<li><em>has-kv</em>: written as <em>[&quot;</em>key<em>&quot;=&quot;</em>value<em>&quot;]</em> or <em>[&quot;</em>key<em>&quot;]</em>. The former selects all elements where the key has the given value, the latter selects all elements where the key has any nonempty value. The quotations marks can be omitted if the entire string contains only alphanumeric characters. Example: <pre>way[name="Adelheidisstraße"]{out;}</pre>.</li>
<li><em>recurse</em>: written as <em>(w.</em>input set<em>)</em>, <em>(r.</em>input set<em>)</em>, <em>(bn.</em>input set<em>)</em>, <em>(bw.</em>input set<em>)</em>, or <em>(br.</em>input set<em>)</em>. Determines the origin from with the given type of elements should be derived. The input set including the leading dot can be omitted. It then default to <em>_</em>. Examples are <pre>way[name="Adelheidisstraße"]node(w){out;}</pre> and <pre>way[name="Adelheidisstraße"]->.foo node(w.foo){out;}</pre>.</li>
<li><em>around</em>: written as <em>(around.</em>input set<em>:</em>radius<em>)</em>. The around statement currently is only compatible to output of type node, and I even haven't decided on the semantics for the other cases. The input set including the leading dot can be omitted. It then default to <em>_</em>. An example is <pre>node[name=&quot;Lichtscheid&quot;]node(around:1000)[highway=bus_stop]{out;}</pre>.</li>
<li><em>user/uid</em>: written as <em>(user:&quot;</em>name<em>&quot;)</em> resp. <em>(uid:</em>id<em>)</em>. Selects all elements last touched by the given user. The user can be selected by her user name (use <em>user</em>) or user id (use <em>uid</em>). Examples are <pre>way(user:"Roland Olbricht"){out;}</pre> or <pre>way(uid:65282){out;}</pre>.</li>
<li><em>newer</em>: similar to <em>user</em>.</li>
</ul>

</body>
</html>
