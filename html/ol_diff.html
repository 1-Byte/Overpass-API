<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" lang="en"></meta>
  <title>OSM3S Experimental Diff</title>
  <script src="http://openlayers.org/api/2.13.1/OpenLayers.js"></script>
  <script src="http://overpass-api.de/OpenStreetMap.js"></script>
  <script src="http://overpass-api.de/overpass.js"></script>
  <script type="text/javascript">
      var lat = 50.82;
      var lon = 7.15;
      var zoom = 16;
      var data_url = "http://overpass-api.de/api/interpreter_0750";
      var map;

      var OSMDiffFormat = OpenLayers.Class(OpenLayers.Format.OSM, {
      
          extent: {},
        
          initialize: function(extent)
          {
              this.extent = extent;
          },
        
          read: function(doc)
          {
              setStatus("Processing data");

              if (typeof doc == "string") {
                  doc = OpenLayers.Format.XML.prototype.read.apply(this, [doc]);
              }
              
              var feat_list = [];
              
              var relations = this.getRelations(doc);
              for (var relation_id in relations) {
                  var relation = relations[relation_id];
                  feat_list.push(relation);
              }
              
              var ways = this.getWays(doc);
              for (var way_id in ways) {
                  var way = ways[way_id];
                  feat_list.push(way);
              }
              
              var nodes = this.getNodes(doc);
              for (var node_id in nodes) {
                  var node = nodes[node_id];
                  feat_list.push(node);
              }
              
              setStatus("Ready");
              return feat_list;
          },

    pointGeomFromNode: function(node)
    {
        var geom = new OpenLayers.Geometry.Point(
            node.getAttribute("lon"),
            node.getAttribute("lat"));
        if (this.internalProjection && this.externalProjection)
            geom.transform(this.externalProjection, this.internalProjection);

        return geom;
    },
    
    isInExtent: function(node)
    {
        var geom = new OpenLayers.Geometry.Point(
            node.getAttribute("lon"),
            node.getAttribute("lat"));
            
        return (geom.x <= this.extent.right && geom.x >= this.extent.left &&
            geom.y <= this.extent.top && geom.y >= this.extent.bottom);
    },
    
    pointListFromWay: function(node_list)
    {
        var lower = 0;
        while (lower < node_list.length && !this.isInExtent(node_list[lower]))
            ++lower;
        if (lower > 0)
            --lower;
            
        var upper = node_list.length;
        while (upper > 0 && !this.isInExtent(node_list[upper-1]))
            --upper;
        if (upper < node_list.length)
            ++upper;
        
        if (upper < lower)
            return new Array();
        
        var point_list = new Array(upper - lower);
        var pos = 0;
        for (var j = lower; j < upper; j++)
            point_list[pos++] = this.pointGeomFromNode(node_list[j]);
            
        return point_list;
    },
          
    getNodes: function(doc) {
        var node_list = doc.getElementsByTagName("node");
        var nodes = {};
        for (var i = 0; i < node_list.length; i++) {
            var node = node_list[i];
            var id = node.getAttribute("id");
            var geom = this.pointGeomFromNode(node);

            var state = {};
            if (node.parentNode.nodeName == "old")
                state = { state: "old" };
            else
                state = { state: "new" };
                
            var feat = new OpenLayers.Feature.Vector(geom, state);
            feat.tags = this.getTags(node);
            feat.osm_id = parseInt(id);
            feat.osm_version = parseInt(node.getAttribute("version"));
            feat.type = "node";
            feat.fid = "node." + feat.osm_id;

            // Since OSM is topological, we stash the node ID internally.
            feat.geometry.osm_id = feat.osm_id;

            if (this.isInExtent(node))
                nodes[id + "." + state.state] = feat;
            
            pushTextualResult(feat);
        }
        return nodes;
    },
          
    getWays: function(doc) {
        var way_list = doc.getElementsByTagName("way");
        var return_ways = {};
        for (var i = 0; i < way_list.length; i++) {
            var way = way_list[i];
            var id = way.getAttribute("id");
            
            var way_nodes = this.pointListFromWay(way.getElementsByTagName("nd"));
            var geom = new OpenLayers.Geometry.LineString(way_nodes);
            
            var state = {};
            if (way.parentNode.nodeName == "old")
                state = { state: "old" };
            else
                state = { state: "new" };
                
            var feat = new OpenLayers.Feature.Vector(geom, state);
            feat.tags = this.getTags(way);
            feat.osm_id = parseInt(id);
            feat.osm_version = parseInt(way.getAttribute("version"));
            feat.type = "way";
            feat.fid = "way." + feat.osm_id;

            if (way_nodes.length >= 2)
                return_ways[id + "." + state.state] = feat;
            
            pushTextualResult(feat);
        }
        return return_ways;
    },

    getRelations: function(doc) {
        var relation_list = doc.getElementsByTagName("relation");
        var return_relations = {};
        for (var i = 0; i < relation_list.length; i++) {
            var relation = relation_list[i];
            var id = relation.getAttribute("id");
            
            var member_list = relation.getElementsByTagName("member");
            var geom = new OpenLayers.Geometry.Collection();
                for (var j = 0; j < member_list.length; j++)
                {
                    if (member_list[j].getAttribute("type") == "node" && this.isInExtent(member_list[j]))
                        geom.addComponent(this.pointGeomFromNode(member_list[j]));
                    else if (member_list[j].getAttribute("type") == "way")
                    {
                        var way_nodes = this.pointListFromWay(member_list[j].getElementsByTagName("nd"));
                        if (way_nodes.length >= 2)
                            geom.addComponent(new OpenLayers.Geometry.LineString(way_nodes));
                    }
                }
            
            var state = {};
            if (relation.parentNode.nodeName == "old")
                state = { state: "old" };
            else
                state = { state: "new" };
                
            var feat = new OpenLayers.Feature.Vector(geom, state);
            feat.tags = this.getTags(relation);
            feat.osm_id = parseInt(id);
            feat.osm_version = parseInt(relation.getAttribute("version"));
            feat.type = "relation";
            feat.fid = "relation." + feat.osm_id;

            if (geom.components.length > 0)
                return_relations[id + "." + state.state] = feat;
            
            pushTextualResult(feat);
        }
        return return_relations;
    },

          strategy: null,

          CLASS_NAME: "OSMDiffFormat"
      });

      var layerNodes = false;
      var layerWays = false;
      var layerRelations = false;
      var layerMapnik = false;
      function refreshData()
      {
          if (layerNodes)
              map.removeLayer(layerNodes);
          if (layerWays)
              map.removeLayer(layerWays);
          if (layerRelations)
              map.removeLayer(layerRelations);
          clearTextualResults();

          setStatus("Loading data");

          var mindate = fullDate(new Date());
          var select_mindate = document.getElementById("select_mindate");
          if (select_mindate)
              mindate = select_mindate.value;

          //Initialise the vector layer using OpenLayers.Format.OSM
          var styleMap = new OpenLayers.StyleMap({
              strokeColor: "blue",
              strokeOpacity: 0.5,
              strokeWidth: 6,
              pointRadius: 10,
              fillColor: "blue",
              fillOpacity: 0.25
          });
          
          var lookup = {
              "old": { strokeColor: "red", fillColor: "red" },
              "new": { strokeColor: "green", fillColor: "green" }
          }
          
          styleMap.addUniqueValueRules("default", "state", lookup);
//           layerNodes = new OpenLayers.Layer.Vector("Polygon", {
//               strategies: [new OpenLayers.Strategy.Fixed()],
//               protocol: new OpenLayers.Protocol.HTTP({
//                   //url: data_url + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
//                   url: data_url + "?data=[adiff:\"" + mindate + "\"];node(bbox);out meta geom;&bbox=" + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
//                   format: new OSMDiffFormat(layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326"))
//               }),
//               styleMap: styleMap,
//               projection: new OpenLayers.Projection("EPSG:4326")
//           });
//           layerWays = new OpenLayers.Layer.Vector("Polygon", {
//               strategies: [new OpenLayers.Strategy.Fixed()],
//               protocol: new OpenLayers.Protocol.HTTP({
//                   //url: data_url + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
//                   url: data_url + "?data=[adiff:\"" + mindate + "\"];way(bbox);out meta geom;&bbox=" + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
//                   format: new OSMDiffFormat(layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326"))
//               }),
//               styleMap: styleMap,
//               projection: new OpenLayers.Projection("EPSG:4326")
//           });
          layerRelations = new OpenLayers.Layer.Vector("Polygon", {
              strategies: [new OpenLayers.Strategy.Fixed()],
              protocol: new OpenLayers.Protocol.HTTP({
                  //url: data_url + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
                  url: data_url + "?data=[adiff:\"" + mindate + "\"];(node(bbox);way(bbox);relation(bbox););out meta geom;&bbox=" + layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326").toBBOX(),
                  format: new OSMDiffFormat(layerMapnik.getExtent().transform("EPSG:900913", "EPSG:4326"))
              }),
              styleMap: styleMap,
              projection: new OpenLayers.Projection("EPSG:4326")
          });

          map.addLayers([/*layerNodes, layerWays,*/ layerRelations]);
      }


      function fullDate(date)
      {
          var result = date.getUTCFullYear();
          result += "-";

          var month = date.getUTCMonth() + 1;
          result += (month <= 9 ? ("0" + month) : month); 

          result += "-";

          var day = date.getUTCDate();
          result += (day <= 9 ? ("0" + day) : day); 

          result += "T";

          var hour = date.getUTCHours();
          result += (hour <= 9 ? ("0" + hour) : hour); 

          result += ":";

          var minute = date.getUTCMinutes();
          result += (minute <= 9 ? ("0" + minute) : minute); 

          result += ":";

          var second = date.getUTCSeconds();
          result += (second <= 9 ? ("0" + second) : second); 

          result += "Z";

          return result;
      }

      function init(){
          map = new OpenLayers.Map ("map", {
          controls:[
              new OpenLayers.Control.Navigation(),
              new OpenLayers.Control.PanZoomBar(),
              new OpenLayers.Control.LayerSwitcher(),
              new OpenLayers.Control.Attribution()],
              maxExtent: new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
              maxResolution: 156543.0399,
              numZoomLevels: 19,
              units: 'm',
              projection: new OpenLayers.Projection("EPSG:900913"),
              displayProjection: new OpenLayers.Projection("EPSG:4326")
          } );

          layerMapnik = new OpenLayers.Layer.OSM.Mapnik("Mapnik");
          map.addLayer(layerMapnik);

          var lonLat = new OpenLayers.LonLat(lon, lat).transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));

          map.setCenter (lonLat, zoom);

          var yesterday = new Date(new Date().getTime() - 86400*1000);
          var select_mindate = document.getElementById("select_mindate");
          if (select_mindate)
              select_mindate.value = fullDate(yesterday);

          refreshData();
      }

      function setStatus(status)
      {
          var status_line = document.getElementById("status_line");
          if (status_line)
              status_line.innerHTML = status;
      }
      
      function clearTextualResults()
      {
          var textual_results = document.getElementById("textual_results");
          if (textual_results)
              textual_results.innerHTML = "";
      }

      function pushTextualResult(feature)
      {
          var result = "<br/><br/>";
          
          if (feature.data && feature.data.state)
              result += feature.data.state + " ";
              
          if (feature.type)
              result += feature.type + " ";
      
          if (feature.osm_id)
              result += feature.osm_id + " ";
              
          if (feature.tags)
          {
              for (tag in feature.tags)
                  result += "<br/>" + tag + "=" + feature.tags[tag];
          }
              
          var textual_results = document.getElementById("textual_results");
          if (textual_results)
              textual_results.innerHTML += result;
      }

  </script>
</head>
<body onload="init()">
  <div id="control_bar" class="control_bar" style="position:absolute; top:0%; left:0%; height:100%; width:30%; z-index:1">
    <form action="#" acceptCharset="UTF-8" onsubmit="alert(&nbsp;foo&nbsp;);">
      <input type="text" id="select_mindate" value=""></input>
      <input type="submit" value="Fetch data" onclick="refreshData()"></input>
    </form>  
    <div id="status_line" class="status_line">Ready</div>
    <div id="textual_results" class="textual_results"><br/>(no entries)</div>
  </div>
  <div id="map" class="smallmap" style="position:absolute; top:0%; left:30%; height:100%; width:70%; z-index:1"></div>

</body>
</html>


